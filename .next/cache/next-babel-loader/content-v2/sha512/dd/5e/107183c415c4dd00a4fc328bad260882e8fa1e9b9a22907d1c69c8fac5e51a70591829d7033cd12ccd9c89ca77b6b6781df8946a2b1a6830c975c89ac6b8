{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _createClass from\"@babel/runtime/helpers/createClass\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{arrayRemove}from\"../../utils\";import{AbstractEdge,AbstractGraph,AbstractVertex}from\"./abstract-graph\";export var DirectedVertex=function(_AbstractVertex){_inherits(DirectedVertex,_AbstractVertex);var _super=_createSuper(DirectedVertex);function DirectedVertex(id){_classCallCheck(this,DirectedVertex);return _super.call(this,id);}return DirectedVertex;}(AbstractVertex);export var DirectedEdge=function(_AbstractEdge){_inherits(DirectedEdge,_AbstractEdge);var _super2=_createSuper(DirectedEdge);function DirectedEdge(src,dest,weight){var _this;_classCallCheck(this,DirectedEdge);_this=_super2.call(this,weight);_this._src=src;_this._dest=dest;return _this;}_createClass(DirectedEdge,[{key:\"src\",get:function get(){return this._src;},set:function set(v){this._src=v;}},{key:\"dest\",get:function get(){return this._dest;},set:function set(v){this._dest=v;}}]);return DirectedEdge;}(AbstractEdge);export var DirectedGraph=function(_AbstractGraph){_inherits(DirectedGraph,_AbstractGraph);var _super3=_createSuper(DirectedGraph);function DirectedGraph(){var _this2;_classCallCheck(this,DirectedGraph);_this2=_super3.call(this);_this2._outEdgeMap=new Map();_this2._inEdgeMap=new Map();return _this2;}_createClass(DirectedGraph,[{key:\"getEdge\",value:function getEdge(srcOrId,destOrId){var edges=[];if(srcOrId!==null&&destOrId!==null){var src=this.getVertex(srcOrId);var dest=this.getVertex(destOrId);if(src&&dest){var srcOutEdges=this._outEdgeMap.get(src);if(srcOutEdges){edges=srcOutEdges.filter(function(edge){return edge.dest===dest.id;});}}}return edges[0]||null;}},{key:\"addEdge\",value:function addEdge(edge){if(!(this.containsVertex(edge.src)&&this.containsVertex(edge.dest))){return false;}var srcVertex=this.getVertex(edge.src);var srcOutEdges=this._outEdgeMap.get(srcVertex);if(srcOutEdges){srcOutEdges.push(edge);}else{this._outEdgeMap.set(srcVertex,[edge]);}var destVertex=this.getVertex(edge.dest);var destInEdges=this._inEdgeMap.get(destVertex);if(destInEdges){destInEdges.push(edge);}else{this._inEdgeMap.set(destVertex,[edge]);}return true;}},{key:\"removeEdgeBetween\",value:function removeEdgeBetween(srcOrId,destOrId){var src=this.getVertex(srcOrId);var dest=this.getVertex(destOrId);var removed=null;if(!src||!dest){return null;}var srcOutEdges=this._outEdgeMap.get(src);if(srcOutEdges){arrayRemove(srcOutEdges,function(edge){return edge.dest===dest.id;});}var destInEdges=this._inEdgeMap.get(dest);if(destInEdges){removed=arrayRemove(destInEdges,function(edge){return edge.src===src.id;})[0]||null;}return removed;}},{key:\"removeEdge\",value:function removeEdge(edge){var removed=null;var src=this.getVertex(edge.src);var dest=this.getVertex(edge.dest);if(src&&dest){var srcOutEdges=this._outEdgeMap.get(src);if(srcOutEdges&&srcOutEdges.length>0){arrayRemove(srcOutEdges,function(edge){return edge.src===src.id;});}var destInEdges=this._inEdgeMap.get(dest);if(destInEdges&&destInEdges.length>0){removed=arrayRemove(destInEdges,function(edge){return edge.dest===dest.id;})[0];}}return removed;}},{key:\"removeAllEdges\",value:function removeAllEdges(src,dest){return[];}},{key:\"incomingEdgesOf\",value:function incomingEdgesOf(vertexOrId){var target=this.getVertex(vertexOrId);if(target){return this._inEdgeMap.get(target)||[];}return[];}},{key:\"outgoingEdgesOf\",value:function outgoingEdgesOf(vertexOrId){var target=this.getVertex(vertexOrId);if(target){return this._outEdgeMap.get(target)||[];}return[];}},{key:\"degreeOf\",value:function degreeOf(vertexOrId){return this.outDegreeOf(vertexOrId)+this.inDegreeOf(vertexOrId);}},{key:\"inDegreeOf\",value:function inDegreeOf(vertexOrId){return this.incomingEdgesOf(vertexOrId).length;}},{key:\"outDegreeOf\",value:function outDegreeOf(vertexOrId){return this.outgoingEdgesOf(vertexOrId).length;}},{key:\"edgesOf\",value:function edgesOf(vertexOrId){return[].concat(_toConsumableArray(this.outgoingEdgesOf(vertexOrId)),_toConsumableArray(this.incomingEdgesOf(vertexOrId)));}},{key:\"getEdgeSrc\",value:function getEdgeSrc(e){return this.getVertex(e.src);}},{key:\"getEdgeDest\",value:function getEdgeDest(e){return this.getVertex(e.dest);}},{key:\"getDestinations\",value:function getDestinations(vertex){if(vertex===null){return[];}var destinations=[];var outgoingEdges=this.outgoingEdgesOf(vertex);for(var _iterator=_createForOfIteratorHelperLoose(outgoingEdges),_step;!(_step=_iterator()).done;){var outEdge=_step.value;var child=this.getEdgeDest(outEdge);if(child){destinations.push(child);}}return destinations;}},{key:\"topologicalSort\",value:function topologicalSort(){var _this3=this;var statusMap=new Map();for(var _iterator2=_createForOfIteratorHelperLoose(this._vertices),_step2;!(_step2=_iterator2()).done;){var entry=_step2.value;statusMap.set(entry[1],0);}var sorted=[];var hasCycle=false;var dfs=function dfs(cur){statusMap.set(cur,1);var children=_this3.getDestinations(cur);for(var _iterator3=_createForOfIteratorHelperLoose(children),_step3;!(_step3=_iterator3()).done;){var child=_step3.value;var childStatus=statusMap.get(child);if(childStatus===0){dfs(child);}else if(childStatus===1){hasCycle=true;}}statusMap.set(cur,2);sorted.push(cur);};for(var _iterator4=_createForOfIteratorHelperLoose(this._vertices),_step4;!(_step4=_iterator4()).done;){var _entry=_step4.value;if(statusMap.get(_entry[1])===0){dfs(_entry[1]);}}if(hasCycle){return null;}return sorted.reverse();}},{key:\"edgeSet\",value:function edgeSet(){var edges=[];this._outEdgeMap.forEach(function(outEdges){edges=[].concat(_toConsumableArray(edges),_toConsumableArray(outEdges));});return edges;}},{key:\"getNeighbors\",value:function getNeighbors(vertexOrId){var neighbors=[];var vertex=this.getVertex(vertexOrId);if(vertex){var outEdges=this.outgoingEdgesOf(vertex);for(var _iterator5=_createForOfIteratorHelperLoose(outEdges),_step5;!(_step5=_iterator5()).done;){var outEdge=_step5.value;var neighbor=this.getVertex(outEdge.dest);neighbors.push(neighbor);}}return neighbors;}},{key:\"getEndsOfEdge\",value:function getEndsOfEdge(edge){if(!this.containsEdge(edge.src,edge.dest)){return null;}var v1=this.getVertex(edge.src);var v2=this.getVertex(edge.dest);if(v1&&v2){return[v1,v2];}else{return null;}}}]);return DirectedGraph;}(AbstractGraph);","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/data-structures/graph/directed-graph.ts"],"names":["DirectedVertex","DirectedEdge","DirectedGraph","_outEdgeMap","_inEdgeMap","edges","srcOrId","destOrId","src","dest","srcOutEdges","edge","srcVertex","destVertex","destInEdges","removed","arrayRemove","target","e","vertex","destinations","outgoingEdges","outEdge","child","statusMap","entry","sorted","hasCycle","dfs","children","childStatus","neighbors","outEdges","neighbor","v1","v2"],"mappings":"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","sourcesContent":["import {arrayRemove} from '../../utils';\nimport {AbstractEdge, AbstractGraph, AbstractVertex, VertexId} from './abstract-graph';\n\nexport class DirectedVertex extends AbstractVertex {\n    constructor(id: VertexId) {\n        super(id);\n    }\n}\n\nexport class DirectedEdge extends AbstractEdge {\n    constructor(src: VertexId, dest: VertexId, weight?: number) {\n        super(weight);\n        this._src = src;\n        this._dest = dest;\n    }\n\n    private _src: VertexId;\n    get src(): VertexId {\n        return this._src;\n    }\n\n    set src(v: VertexId) {\n        this._src = v;\n    }\n\n\n    private _dest: VertexId;\n    get dest(): VertexId {\n        return this._dest;\n    }\n\n    set dest(v: VertexId) {\n        this._dest = v;\n    }\n}\n\nexport interface I_DirectedGraph<V, E> {\n    incomingEdgesOf(vertex: V): E[];\n\n    outgoingEdgesOf(vertex: V): E[];\n\n    inDegreeOf(vertexOrId: V | VertexId): number;\n\n    outDegreeOf(vertexOrId: V | VertexId): number;\n\n    getEdgeSrc(e: E): V | null;\n\n    getEdgeDest(e: E): V | null;\n}\n\n// 0 means unknown, 1 means visiting, 2 means visited;\nexport type TopologicalStatus = 0 | 1 | 2;\n\n// Strongly connected, One direction connected, Weakly connected\nexport class DirectedGraph<V extends DirectedVertex, E extends DirectedEdge> extends AbstractGraph<V, E> implements I_DirectedGraph<V, E> {\n\n    protected _outEdgeMap: Map<V, E[]> = new Map<V, E[]>();\n\n    protected _inEdgeMap: Map<V, E[]> = new Map<V, E[]>();\n\n    constructor() {\n        super();\n    }\n\n    getEdge(srcOrId: V | null | VertexId, destOrId: V | null | VertexId): E | null {\n        let edges: E[] = [];\n\n        if (srcOrId !== null && destOrId !== null) {\n            const src: V | null = this.getVertex(srcOrId);\n            const dest: V | null = this.getVertex(destOrId);\n\n            if (src && dest) {\n                const srcOutEdges = this._outEdgeMap.get(src);\n                if (srcOutEdges) {\n                    edges = srcOutEdges.filter(edge => edge.dest === dest.id);\n                }\n            }\n        }\n\n        return edges[0] || null;\n    }\n\n    addEdge(edge: E): boolean {\n        if (!(this.containsVertex(edge.src) && this.containsVertex(edge.dest))) {\n            return false;\n        }\n\n        const srcVertex = this.getVertex(edge.src)!;\n        const srcOutEdges = this._outEdgeMap.get(srcVertex);\n        if (srcOutEdges) {\n            srcOutEdges.push(edge);\n        } else {\n            this._outEdgeMap.set(srcVertex, [edge]);\n        }\n\n        const destVertex = this.getVertex(edge.dest)!;\n        const destInEdges = this._inEdgeMap.get(destVertex);\n        if (destInEdges) {\n            destInEdges.push(edge);\n        } else {\n            this._inEdgeMap.set(destVertex, [edge]);\n        }\n\n        return true;\n    }\n\n    removeEdgeBetween(srcOrId: V | VertexId, destOrId: V | VertexId): E | null {\n\n        const src: V | null = this.getVertex(srcOrId);\n        const dest: V | null = this.getVertex(destOrId);\n        let removed: E | null = null;\n        if (!src || !dest) {\n            return null;\n        }\n\n        const srcOutEdges = this._outEdgeMap.get(src);\n        if (srcOutEdges) {\n            arrayRemove<E>(srcOutEdges, edge => edge.dest === dest.id);\n        }\n\n        const destInEdges = this._inEdgeMap.get(dest);\n        if (destInEdges) {\n            removed = arrayRemove<E>(destInEdges, edge => edge.src === src.id)[0] || null;\n        }\n        return removed;\n    }\n\n    removeEdge(edge: E): E | null {\n        let removed: E | null = null;\n        const src = this.getVertex(edge.src);\n        const dest = this.getVertex(edge.dest);\n        if (src && dest) {\n            const srcOutEdges = this._outEdgeMap.get(src);\n            if (srcOutEdges && srcOutEdges.length > 0) {\n                arrayRemove(srcOutEdges, edge => edge.src === src.id);\n            }\n\n            const destInEdges = this._inEdgeMap.get(dest);\n            if (destInEdges && destInEdges.length > 0) {\n                removed = arrayRemove(destInEdges, edge => edge.dest === dest.id)[0];\n            }\n\n        }\n\n        return removed;\n    }\n\n    removeAllEdges(src: VertexId | V, dest: VertexId | V): E[] {\n        return [];\n    }\n\n    incomingEdgesOf(vertexOrId: V | VertexId): E[] {\n        const target = this.getVertex(vertexOrId);\n        if (target) {\n            return this._inEdgeMap.get(target) || [];\n        }\n        return [];\n    }\n\n    outgoingEdgesOf(vertexOrId: V | VertexId): E[] {\n        const target = this.getVertex(vertexOrId);\n        if (target) {\n            return this._outEdgeMap.get(target) || [];\n        }\n        return [];\n    }\n\n    degreeOf(vertexOrId: VertexId | V): number {\n        return this.outDegreeOf(vertexOrId) + this.inDegreeOf(vertexOrId);\n    }\n\n    inDegreeOf(vertexOrId: VertexId | V): number {\n        return this.incomingEdgesOf(vertexOrId).length;\n    }\n\n    outDegreeOf(vertexOrId: VertexId | V): number {\n        return this.outgoingEdgesOf(vertexOrId).length;\n    }\n\n    edgesOf(vertexOrId: VertexId | V): E[] {\n        return [...this.outgoingEdgesOf(vertexOrId), ...this.incomingEdgesOf(vertexOrId)];\n    }\n\n    getEdgeSrc(e: E): V | null {\n        return this.getVertex(e.src);\n    }\n\n    getEdgeDest(e: E): V | null {\n        return this.getVertex(e.dest);\n    }\n\n    getDestinations(vertex: V | null): V[] {\n        if (vertex === null) {\n            return [];\n        }\n        const destinations: V[] = [];\n        const outgoingEdges = this.outgoingEdgesOf(vertex);\n        for (let outEdge of outgoingEdges) {\n            const child = this.getEdgeDest(outEdge);\n            if (child) {\n                destinations.push(child);\n            }\n        }\n        return destinations;\n    }\n\n    /**--- start find cycles --- */\n\n    /**\n     * when stored with adjacency list time: O(V+E)\n     * when stored with adjacency matrix time: O(V^2)\n     */\n    topologicalSort(): V[] | null {\n        // vector<vector<int>> g;\n        // vector<int> color;\n        // int last;\n        // bool hasCycle;\n        //\n        // bool topo_sort() {\n        //     int n = g.size();\n        //     vector<int> degree(n, 0);\n        //     queue<int> q;\n        //     for (int i = 0; i < n; i++) {\n        //         degree[i] = g[i].size();\n        //         if (degree[i] <= 1) {\n        //             q.push(i);\n        //         }\n        //     }\n        //     int cnt = 0;\n        //     while (!q.empty()) {\n        //         cnt++;\n        //         int root = q.front();\n        //         q.pop();\n        //         for (auto child : g[root]) {\n        //             degree[child]--;\n        //             if (degree[child] == 1) {\n        //                 q.push(child);\n        //             }\n        //         }\n        //     }\n        //     return (cnt != n);\n        // }\n        // When judging whether there is a cycle in the undirected graph, all nodes with degree of **<= 1** are enqueued\n        // When judging whether there is a cycle in the directed graph, all nodes with **in degree = 0** are enqueued\n        const statusMap: Map<V, TopologicalStatus> = new Map<V, TopologicalStatus>();\n        for (let entry of this._vertices) {\n            statusMap.set(entry[1], 0);\n        }\n\n        const sorted: V[] = [];\n        let hasCycle = false;\n        const dfs = (cur: V) => {\n            statusMap.set(cur, 1);\n            const children = this.getDestinations(cur);\n            for (let child of children) {\n                const childStatus = statusMap.get(child);\n                if (childStatus === 0) {\n                    dfs(child);\n                } else if (childStatus === 1) {\n                    hasCycle = true;\n                }\n            }\n            statusMap.set(cur, 2);\n            sorted.push(cur);\n        };\n\n        for (let entry of this._vertices) {\n            if (statusMap.get(entry[1]) === 0) {\n                dfs(entry[1]);\n            }\n        }\n\n        if (hasCycle) {\n            return null;\n        }\n        return sorted.reverse();\n    }\n\n    /**--- end find cycles --- */\n\n    edgeSet(): E[] {\n        let edges: E[] = [];\n        this._outEdgeMap.forEach(outEdges => {\n            edges = [...edges, ...outEdges];\n        });\n        return edges;\n    }\n\n    getNeighbors(vertexOrId: V | VertexId): V[] {\n        const neighbors: V[] = [];\n        const vertex = this.getVertex(vertexOrId);\n        if (vertex) {\n            const outEdges = this.outgoingEdgesOf(vertex);\n            for (let outEdge of outEdges) {\n                const neighbor = this.getVertex(outEdge.dest)!;\n                neighbors.push(neighbor);\n            }\n        }\n        return neighbors;\n    }\n\n    getEndsOfEdge(edge: E): [V, V] | null {\n        if (!this.containsEdge(edge.src, edge.dest)) {\n            return null;\n        }\n        const v1 = this.getVertex(edge.src);\n        const v2 = this.getVertex(edge.dest);\n        if (v1 && v2) {\n            return [v1, v2];\n        } else {\n            return null;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}