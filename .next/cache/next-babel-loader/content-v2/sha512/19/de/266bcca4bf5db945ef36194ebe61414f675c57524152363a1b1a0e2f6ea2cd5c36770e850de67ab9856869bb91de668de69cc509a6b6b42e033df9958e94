{"ast":null,"code":"\"use strict\";var _interopRequireDefault2=require(\"@babel/runtime/helpers/interopRequireDefault\");var _extends2=_interopRequireDefault2(require(\"@babel/runtime/helpers/extends\"));var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");exports.__esModule=true;exports.markAssetError=markAssetError;exports.isAssetError=isAssetError;exports.getClientBuildManifest=getClientBuildManifest;exports.default=void 0;var _getAssetPathFromRoute=_interopRequireDefault(require(\"../next-server/lib/router/utils/get-asset-path-from-route\"));var _requestIdleCallback=require(\"./request-idle-callback\");var MS_MAX_IDLE_DELAY=3800;function withFuture(key,map,generator){var entry=map.get(key);if(entry){if('future'in entry){return entry.future;}return Promise.resolve(entry);}var resolver;var prom=new Promise(function(resolve){resolver=resolve;});map.set(key,entry={resolve:resolver,future:prom});return generator?generator().then(function(value){return resolver(value),value;}):prom;}function hasPrefetch(link){try{link=document.createElement('link');return!!window.MSInputMethodContext&&!!document.documentMode||link.relList.supports('prefetch');}catch(_unused){return false;}}var canPrefetch=hasPrefetch();function prefetchViaDom(href,as,link){return new Promise(function(res,rej){if(document.querySelector(\"link[rel=\\\"prefetch\\\"][href^=\\\"\"+href+\"\\\"]\")){return res();}link=document.createElement('link');if(as)link.as=as;link.rel=\"prefetch\";link.crossOrigin=process.env.__NEXT_CROSS_ORIGIN;link.onload=res;link.onerror=rej;link.href=href;document.head.appendChild(link);});}var ASSET_LOAD_ERROR=Symbol('ASSET_LOAD_ERROR');function markAssetError(err){return Object.defineProperty(err,ASSET_LOAD_ERROR,{});}function isAssetError(err){return err&&ASSET_LOAD_ERROR in err;}function appendScript(src,script){return new Promise(function(resolve,reject){script=document.createElement('script');script.onload=resolve;script.onerror=function(){return reject(markAssetError(new Error(\"Failed to load script: \"+src)));};script.crossOrigin=process.env.__NEXT_CROSS_ORIGIN;script.src=src;document.body.appendChild(script);});}function resolvePromiseWithTimeout(p,ms,err){return new Promise(function(resolve,reject){var cancelled=false;p.then(function(r){cancelled=true;resolve(r);}).catch(reject);(0,_requestIdleCallback.requestIdleCallback)(function(){return setTimeout(function(){if(!cancelled){reject(err);}},ms);});});}function getClientBuildManifest(){if(self.__BUILD_MANIFEST){return Promise.resolve(self.__BUILD_MANIFEST);}var onBuildManifest=new Promise(function(resolve){var cb=self.__BUILD_MANIFEST_CB;self.__BUILD_MANIFEST_CB=function(){resolve(self.__BUILD_MANIFEST);cb&&cb();};});return resolvePromiseWithTimeout(onBuildManifest,MS_MAX_IDLE_DELAY,markAssetError(new Error('Failed to load client build manifest')));}function getFilesForRoute(assetPrefix,route){if(true){return Promise.resolve({scripts:[assetPrefix+'/_next/static/chunks/pages'+encodeURI((0,_getAssetPathFromRoute.default)(route,'.js'))],css:[]});}return getClientBuildManifest().then(function(manifest){if(!(route in manifest)){throw markAssetError(new Error(\"Failed to lookup route: \"+route));}var allFiles=manifest[route].map(function(entry){return assetPrefix+'/_next/'+encodeURI(entry);});return{scripts:allFiles.filter(function(v){return v.endsWith('.js');}),css:allFiles.filter(function(v){return v.endsWith('.css');})};});}function createRouteLoader(assetPrefix){var entrypoints=new Map();var loadedScripts=new Map();var styleSheets=new Map();var routes=new Map();function maybeExecuteScript(src){var prom=loadedScripts.get(src);if(prom){return prom;}if(document.querySelector(\"script[src^=\\\"\"+src+\"\\\"]\")){return Promise.resolve();}loadedScripts.set(src,prom=appendScript(src));return prom;}function fetchStyleSheet(href){var prom=styleSheets.get(href);if(prom){return prom;}styleSheets.set(href,prom=fetch(href).then(function(res){if(!res.ok){throw new Error(\"Failed to load stylesheet: \"+href);}return res.text().then(function(text){return{href:href,content:text};});}).catch(function(err){throw markAssetError(err);}));return prom;}return{whenEntrypoint:function whenEntrypoint(route){return withFuture(route,entrypoints);},onEntrypoint:function onEntrypoint(route,execute){Promise.resolve(execute).then(function(fn){return fn();}).then(function(exports){return{component:exports&&exports.default||exports,exports:exports};},function(err){return{error:err};}).then(function(input){var old=entrypoints.get(route);entrypoints.set(route,input);if(old&&'resolve'in old)old.resolve(input);});},loadRoute:function loadRoute(route,prefetch){var _this=this;return withFuture(route,routes,function(){return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix,route).then(function(_ref){var scripts=_ref.scripts,css=_ref.css;return Promise.all([entrypoints.has(route)?[]:Promise.all(scripts.map(maybeExecuteScript)),Promise.all(css.map(fetchStyleSheet))]);}).then(function(res){return _this.whenEntrypoint(route).then(function(entrypoint){return{entrypoint:entrypoint,styles:res[1]};});}),MS_MAX_IDLE_DELAY,markAssetError(new Error(\"Route did not complete loading: \"+route))).then(function(_ref2){var entrypoint=_ref2.entrypoint,styles=_ref2.styles;var res=(0,_extends2.default)({styles:styles},entrypoint);return'error'in entrypoint?entrypoint:res;}).catch(function(err){if(prefetch){throw err;}return{error:err};});});},prefetch:function prefetch(route){var _this2=this;var cn;if(cn=navigator.connection){if(cn.saveData||/2g/.test(cn.effectiveType))return Promise.resolve();}return getFilesForRoute(assetPrefix,route).then(function(output){return Promise.all(canPrefetch?output.scripts.map(function(script){return prefetchViaDom(script,'script');}):[]);}).then(function(){(0,_requestIdleCallback.requestIdleCallback)(function(){return _this2.loadRoute(route,true).catch(function(){});});}).catch(function(){});}};}var _default=createRouteLoader;exports.default=_default;","map":{"version":3,"sources":["../../client/route-loader.ts"],"names":["MS_MAX_IDLE_DELAY","entry","map","Promise","prom","resolve","resolver","future","generator","value","link","document","window","canPrefetch","hasPrefetch","res","process","ASSET_LOAD_ERROR","Symbol","Object","err","script","reject","markAssetError","cancelled","r","setTimeout","self","onBuildManifest","cb","resolvePromiseWithTimeout","scripts","assetPrefix","encodeURI","css","getClientBuildManifest","manifest","route","allFiles","v","entrypoints","loadedScripts","styleSheets","routes","appendScript","fetch","text","href","content","whenEntrypoint","withFuture","onEntrypoint","fn","exports","component","error","input","old","loadRoute","getFilesForRoute","entrypoint","styles","prefetch","cn","navigator","output","prefetchViaDom","createRouteLoader"],"mappings":"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","sourcesContent":["import { ComponentType } from 'react'\nimport { ClientBuildManifest } from '../build/webpack/plugins/build-manifest-plugin'\nimport getAssetPathFromRoute from '../next-server/lib/router/utils/get-asset-path-from-route'\nimport { requestIdleCallback } from './request-idle-callback'\n\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800\n\ndeclare global {\n  interface Window {\n    __BUILD_MANIFEST?: ClientBuildManifest\n    __BUILD_MANIFEST_CB?: Function\n  }\n}\n\nexport interface LoadedEntrypointSuccess {\n  component: ComponentType\n  exports: any\n}\nexport interface LoadedEntrypointFailure {\n  error: unknown\n}\nexport type RouteEntrypoint = LoadedEntrypointSuccess | LoadedEntrypointFailure\n\nexport interface RouteStyleSheet {\n  href: string\n  content: string\n}\n\nexport interface LoadedRouteSuccess extends LoadedEntrypointSuccess {\n  styles: RouteStyleSheet[]\n}\nexport interface LoadedRouteFailure {\n  error: unknown\n}\nexport type RouteLoaderEntry = LoadedRouteSuccess | LoadedRouteFailure\n\nexport type Future<V> = {\n  resolve: (entrypoint: V) => void\n  future: Promise<V>\n}\nfunction withFuture<T>(\n  key: string,\n  map: Map<string, Future<T> | T>,\n  generator?: () => Promise<T>\n): Promise<T> {\n  let entry: Future<T> | T | undefined = map.get(key)\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future\n    }\n    return Promise.resolve(entry)\n  }\n  let resolver: (entrypoint: T) => void\n  const prom: Promise<T> = new Promise<T>((resolve) => {\n    resolver = resolve\n  })\n  map.set(key, (entry = { resolve: resolver!, future: prom }))\n  return generator\n    ? // eslint-disable-next-line no-sequences\n      generator().then((value) => (resolver(value), value))\n    : prom\n}\n\nexport interface RouteLoader {\n  whenEntrypoint(route: string): Promise<RouteEntrypoint>\n  onEntrypoint(route: string, execute: () => unknown): void\n  loadRoute(route: string, prefetch?: boolean): Promise<RouteLoaderEntry>\n  prefetch(route: string): Promise<void>\n}\n\nfunction hasPrefetch(link?: HTMLLinkElement): boolean {\n  try {\n    link = document.createElement('link')\n    return (\n      // detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      (!!window.MSInputMethodContext && !!(document as any).documentMode) ||\n      link.relList.supports('prefetch')\n    )\n  } catch {\n    return false\n  }\n}\n\nconst canPrefetch: boolean = hasPrefetch()\n\nfunction prefetchViaDom(\n  href: string,\n  as: string,\n  link?: HTMLLinkElement\n): Promise<any> {\n  return new Promise((res, rej) => {\n    if (document.querySelector(`link[rel=\"prefetch\"][href^=\"${href}\"]`)) {\n      return res()\n    }\n\n    link = document.createElement('link')\n\n    // The order of property assignment here is intentional:\n    if (as) link!.as = as\n    link!.rel = `prefetch`\n    link!.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n    link!.onload = res\n    link!.onerror = rej\n\n    // `href` should always be last:\n    link!.href = href\n\n    document.head.appendChild(link)\n  })\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR')\n// TODO: unexport\nexport function markAssetError(err: Error): Error {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {})\n}\n\nexport function isAssetError(err?: Error): boolean | undefined {\n  return err && ASSET_LOAD_ERROR in err\n}\n\nfunction appendScript(\n  src: string,\n  script?: HTMLScriptElement\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script')\n\n    // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n    script.onload = resolve\n    script.onerror = () =>\n      reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n\n    // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN!\n\n    // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n    script.src = src\n    document.body.appendChild(script)\n  })\n}\n\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout<T>(\n  p: Promise<T>,\n  ms: number,\n  err: Error\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    let cancelled = false\n\n    p.then((r) => {\n      // Resolved, cancel the timeout\n      cancelled = true\n      resolve(r)\n    }).catch(reject)\n\n    requestIdleCallback(() =>\n      setTimeout(() => {\n        if (!cancelled) {\n          reject(err)\n        }\n      }, ms)\n    )\n  })\n}\n\n// TODO: stop exporting or cache the failure\n// It'd be best to stop exporting this. It's an implementation detail. We're\n// only exporting it for backwards compatibilty with the `page-loader`.\n// Only cache this response as a last resort if we cannot eliminate all other\n// code branches that use the Build Manifest Callback and push them through\n// the Route Loader interface.\nexport function getClientBuildManifest(): Promise<ClientBuildManifest> {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST)\n  }\n\n  const onBuildManifest: Promise<ClientBuildManifest> = new Promise<\n    ClientBuildManifest\n  >((resolve) => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST!)\n      cb && cb()\n    }\n  })\n\n  return resolvePromiseWithTimeout<ClientBuildManifest>(\n    onBuildManifest,\n    MS_MAX_IDLE_DELAY,\n    markAssetError(new Error('Failed to load client build manifest'))\n  )\n}\n\ninterface RouteFiles {\n  scripts: string[]\n  css: string[]\n}\nfunction getFilesForRoute(\n  assetPrefix: string,\n  route: string\n): Promise<RouteFiles> {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [\n        assetPrefix +\n          '/_next/static/chunks/pages' +\n          encodeURI(getAssetPathFromRoute(route, '.js')),\n      ],\n      // Styles are handled by `style-loader` in development:\n      css: [],\n    })\n  }\n  return getClientBuildManifest().then((manifest) => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`))\n    }\n    const allFiles = manifest[route].map(\n      (entry) => assetPrefix + '/_next/' + encodeURI(entry)\n    )\n    return {\n      scripts: allFiles.filter((v) => v.endsWith('.js')),\n      css: allFiles.filter((v) => v.endsWith('.css')),\n    }\n  })\n}\n\nfunction createRouteLoader(assetPrefix: string): RouteLoader {\n  const entrypoints: Map<\n    string,\n    Future<RouteEntrypoint> | RouteEntrypoint\n  > = new Map()\n  const loadedScripts: Map<string, Promise<unknown>> = new Map()\n  const styleSheets: Map<string, Promise<RouteStyleSheet>> = new Map()\n  const routes: Map<\n    string,\n    Future<RouteLoaderEntry> | RouteLoaderEntry\n  > = new Map()\n\n  function maybeExecuteScript(src: string): Promise<unknown> {\n    let prom: Promise<unknown> | undefined = loadedScripts.get(src)\n    if (prom) {\n      return prom\n    }\n\n    // Skip executing script if it's already in the DOM:\n    if (document.querySelector(`script[src^=\"${src}\"]`)) {\n      return Promise.resolve()\n    }\n\n    loadedScripts.set(src, (prom = appendScript(src)))\n    return prom\n  }\n\n  function fetchStyleSheet(href: string): Promise<RouteStyleSheet> {\n    let prom: Promise<RouteStyleSheet> | undefined = styleSheets.get(href)\n    if (prom) {\n      return prom\n    }\n\n    styleSheets.set(\n      href,\n      (prom = fetch(href)\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error(`Failed to load stylesheet: ${href}`)\n          }\n          return res.text().then((text) => ({ href: href, content: text }))\n        })\n        .catch((err) => {\n          throw markAssetError(err)\n        }))\n    )\n    return prom\n  }\n\n  return {\n    whenEntrypoint(route: string) {\n      return withFuture(route, entrypoints)\n    },\n    onEntrypoint(route: string, execute: () => unknown) {\n      Promise.resolve(execute)\n        .then((fn) => fn())\n        .then(\n          (exports: any) => ({\n            component: (exports && exports.default) || exports,\n            exports: exports,\n          }),\n          (err) => ({ error: err })\n        )\n        .then((input: RouteEntrypoint) => {\n          const old = entrypoints.get(route)\n          entrypoints.set(route, input)\n          if (old && 'resolve' in old) old.resolve(input)\n        })\n    },\n    loadRoute(route: string, prefetch?: boolean) {\n      return withFuture<RouteLoaderEntry>(route, routes, () => {\n        return resolvePromiseWithTimeout(\n          getFilesForRoute(assetPrefix, route)\n            .then(({ scripts, css }) => {\n              return Promise.all([\n                entrypoints.has(route)\n                  ? []\n                  : Promise.all(scripts.map(maybeExecuteScript)),\n                Promise.all(css.map(fetchStyleSheet)),\n              ] as const)\n            })\n            .then((res) => {\n              return this.whenEntrypoint(route).then((entrypoint) => ({\n                entrypoint,\n                styles: res[1],\n              }))\n            }),\n          MS_MAX_IDLE_DELAY,\n          markAssetError(new Error(`Route did not complete loading: ${route}`))\n        )\n          .then(({ entrypoint, styles }) => {\n            const res: RouteLoaderEntry = Object.assign<\n              { styles: RouteStyleSheet[] },\n              RouteEntrypoint\n            >({ styles: styles! }, entrypoint)\n            return 'error' in entrypoint ? entrypoint : res\n          })\n          .catch((err) => {\n            if (prefetch) {\n              // we don't want to cache errors during prefetch\n              throw err\n            }\n            return { error: err }\n          })\n      })\n    },\n    prefetch(route: string): Promise<void> {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn\n      if ((cn = (navigator as any).connection)) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve()\n      }\n      return getFilesForRoute(assetPrefix, route)\n        .then((output) =>\n          Promise.all(\n            canPrefetch\n              ? output.scripts.map((script) => prefetchViaDom(script, 'script'))\n              : []\n          )\n        )\n        .then(() => {\n          requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}))\n        })\n        .catch(\n          // swallow prefetch errors\n          () => {}\n        )\n    },\n  }\n}\n\nexport default createRouteLoader\n"]},"metadata":{},"sourceType":"script"}