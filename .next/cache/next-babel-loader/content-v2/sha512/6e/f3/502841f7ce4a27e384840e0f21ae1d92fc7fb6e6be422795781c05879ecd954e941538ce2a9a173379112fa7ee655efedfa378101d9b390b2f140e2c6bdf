{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports.getRouteRegex=getRouteRegex;function escapeRegex(str){return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g,'\\\\$&');}function parseParameter(param){var optional=param.startsWith('[')&&param.endsWith(']');if(optional){param=param.slice(1,-1);}var repeat=param.startsWith('...');if(repeat){param=param.slice(3);}return{key:param,repeat:repeat,optional:optional};}function getRouteRegex(normalizedRoute){var segments=(normalizedRoute.replace(/\\/$/,'')||'/').slice(1).split('/');var groups={};var groupIndex=1;var parameterizedRoute=segments.map(function(segment){if(segment.startsWith('[')&&segment.endsWith(']')){var _parseParameter=parseParameter(segment.slice(1,-1)),key=_parseParameter.key,optional=_parseParameter.optional,repeat=_parseParameter.repeat;groups[key]={pos:groupIndex++,repeat:repeat,optional:optional};return repeat?optional?'(?:/(.+?))?':'/(.+?)':'/([^/]+?)';}else{return\"/\"+escapeRegex(segment);}}).join('');if(false){var routeKeyCharCode=97;var routeKeyCharLength=1;var getSafeRouteKey=function getSafeRouteKey(){var routeKey='';for(var i=0;i<routeKeyCharLength;i++){routeKey+=String.fromCharCode(routeKeyCharCode);routeKeyCharCode++;if(routeKeyCharCode>122){routeKeyCharLength++;routeKeyCharCode=97;}}return routeKey;};var routeKeys={};var namedParameterizedRoute=segments.map(function(segment){if(segment.startsWith('[')&&segment.endsWith(']')){var _parseParameter2=parseParameter(segment.slice(1,-1)),key=_parseParameter2.key,optional=_parseParameter2.optional,repeat=_parseParameter2.repeat;var cleanedKey=key.replace(/\\W/g,'');var invalidKey=false;if(cleanedKey.length===0||cleanedKey.length>30){invalidKey=true;}if(!isNaN(parseInt(cleanedKey.substr(0,1)))){invalidKey=true;}if(invalidKey){cleanedKey=getSafeRouteKey();}routeKeys[cleanedKey]=key;return repeat?optional?\"(?:/(?<\"+cleanedKey+\">.+?))?\":\"/(?<\"+cleanedKey+\">.+?)\":\"/(?<\"+cleanedKey+\">[^/]+?)\";}else{return\"/\"+escapeRegex(segment);}}).join('');return{re:new RegExp(\"^\"+parameterizedRoute+\"(?:/)?$\"),groups:groups,routeKeys:routeKeys,namedRegex:\"^\"+namedParameterizedRoute+\"(?:/)?$\"};}return{re:new RegExp(\"^\"+parameterizedRoute+\"(?:/)?$\"),groups:groups};}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["str","optional","param","repeat","key","segments","normalizedRoute","groups","groupIndex","parameterizedRoute","segment","parseParameter","pos","escapeRegex","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","isNaN","parseInt","re","namedRegex"],"mappings":"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","sourcesContent":["export interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  routeKeys?: { [named: string]: string }\n  groups: { [groupName: string]: Group }\n} {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/')\n    .slice(1)\n    .split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}