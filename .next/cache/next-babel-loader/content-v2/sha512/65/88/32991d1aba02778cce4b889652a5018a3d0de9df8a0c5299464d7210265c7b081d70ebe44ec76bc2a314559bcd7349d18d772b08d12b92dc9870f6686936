{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{bunnyConsole,timeStart}from\"../utils\";export var runAlgorithm=function runAlgorithm(algorithm){var output,startTime,_len,args,_key,result,timeSpent,_args=arguments;return _regeneratorRuntime.async(function runAlgorithm$(_context){while(1){switch(_context.prev=_context.next){case 0:output=_args.length>1&&_args[1]!==undefined?_args[1]:true;startTime=timeStart();for(_len=_args.length,args=new Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=_args[_key];}_context.next=5;return _regeneratorRuntime.awrap(algorithm.apply(void 0,args));case 5:result=_context.sent;timeSpent=(performance?performance.now():new Date().getTime())-startTime;bunnyConsole.log(algorithm.name,'result -> ',output==='stringify'?JSON.stringify(result):output?result:'','time spent -> ',timeSpent.toFixed(2)+'ms');return _context.abrupt(\"return\",result);case 9:case\"end\":return _context.stop();}}},null,null,null,Promise);};export var isOneDiffOrdered=function isOneDiffOrdered(wordA,wordB){var diffCount=0;for(var i=0,len=wordA.length;i<len;i++){if(wordA[i]!==wordB[i]){diffCount++;if(diffCount>1){return false;}}}return true;};export var isOneDiffOrderedPieced=function isOneDiffOrderedPieced(wordA,wordB){for(var i=0,len=wordA.length;i<len;i++){for(var j=0;j<26;j++){var piecedWord=wordA.substr(0,i)+String.fromCharCode(97+j)+wordA.substr(i+1);if(piecedWord===wordB){return true;}}}return false;};export var isOneDiff=function isOneDiff(word1,word2){var diffCount=0;for(var _iterator=_createForOfIteratorHelperLoose(word1),_step;!(_step=_iterator()).done;){var c1=_step.value;if(!word2.includes(c1)){diffCount++;if(diffCount>1){return false;}}}diffCount=0;for(var _iterator2=_createForOfIteratorHelperLoose(word2),_step2;!(_step2=_iterator2()).done;){var c2=_step2.value;if(!word1.includes(c2)){diffCount++;if(diffCount>1){return false;}}}return true;};var searchInSortedArray=function searchInSortedArray(nums,target){var left=0,right=nums.length-1;while(left<=right){var mid=left+Math.floor((right-left)/2);var midEle=nums[mid];var leftEle=nums[left];if(target===midEle)return mid;if(target<leftEle){right=mid-1;}else{left=mid+1;}}return-1;};export var Coordinate=function Coordinate(y,x){_classCallCheck(this,Coordinate);this.y=y;this.x=x;};_c=Coordinate;export var fourthQuadrantMove=function fourthQuadrantMove(departure,direction,matrix,judgeDeadOrDeadCells){var destinationX=departure.x,destinationY=departure.y;switch(direction){case'up':destinationY=departure.y+1;break;case'right':destinationX=departure.x+1;break;case'down':destinationY=departure.y-1;break;case'left':destinationX=departure.x-1;break;}var destination={y:destinationY,x:destinationX};if(matrix){if(destinationY<0||destinationY>matrix.length-1||destinationX<0||destinationX>matrix[destinationY].length-1){return undefined;}}if(judgeDeadOrDeadCells){if(judgeDeadOrDeadCells instanceof Function){if(judgeDeadOrDeadCells(destination)){return undefined;}}else{for(var _iterator3=_createForOfIteratorHelperLoose(judgeDeadOrDeadCells),_step3;!(_step3=_iterator3()).done;){var deadCell=_step3.value;if(destination.x===deadCell.x&&destination.y===deadCell.y){return undefined;}}}}return destination;};export var fourthQuadrantMoveByIndex=function fourthQuadrantMoveByIndex(departure,direction,matrix,judgeDeadOrDeadCells){var directions={up:[-1,0],right:[0,1],down:[1,0],left:[0,-1]};var newRow=departure[0]+directions[direction][0];var newCol=departure[1]+directions[direction][1];var destination=[newRow,newCol];if(matrix){if(newRow<0||newRow>matrix.length-1||newCol<0||newCol>matrix[newRow].length-1){return undefined;}}if(judgeDeadOrDeadCells){if(judgeDeadOrDeadCells instanceof Function){if(judgeDeadOrDeadCells(destination)){return undefined;}}else{for(var _iterator4=_createForOfIteratorHelperLoose(judgeDeadOrDeadCells),_step4;!(_step4=_iterator4()).done;){var deadCell=_step4.value;if(newRow===deadCell[0]&&newCol===deadCell[1]){return undefined;}}}}return destination;};export var getRouteByParentsHash=function getRouteByParentsHash(parents,leaf,hashFunction){var route=[leaf];var value=[leaf];while(value.length>0){var cur=value.shift();var curParent=parents[hashFunction(cur)];if(curParent){value.push(curParent);route.push(curParent);}}return route.reverse();};export var getDirectionVector=function getDirectionVector(from,to){if(!from||!to){return{x:0,y:0};}var horizontal;var vertical;horizontal=to.x>from.x?1:-1;vertical=to.y>from.y?1:-1;if(to.x===from.x){horizontal=0;}if(to.y===from.y){vertical=0;}return{x:horizontal,y:vertical};};var _c;$RefreshReg$(_c,\"Coordinate\");","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/algorithms/helpers.ts"],"names":["runAlgorithm","output","args","startTime","timeStart","result","algorithm","timeSpent","performance","bunnyConsole","JSON","isOneDiffOrdered","diffCount","i","len","wordA","wordB","isOneDiffOrderedPieced","j","piecedWord","String","isOneDiff","c1","word2","c2","word1","searchInSortedArray","left","right","nums","mid","Math","midEle","leftEle","target","Coordinate","fourthQuadrantMove","destinationX","departure","destinationY","destination","y","x","matrix","judgeDeadOrDeadCells","deadCell","fourthQuadrantMoveByIndex","directions","up","down","newRow","newCol","getRouteByParentsHash","route","value","cur","curParent","parents","hashFunction","getDirectionVector","horizontal","to","from","vertical"],"mappings":"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","sourcesContent":["import {bunnyConsole, timeStart} from '../utils';\n\n// Use Map:\n//       When the stored key is not a string/number/or Symbol, select Map, because Object does not support\n//       When storing large amounts of data, choose Map because it occupies less memory\n//       When you need to perform many operations to add/remove elements, choose Map because it is faster\n//       If you need to maintain the order when inserting, choose Map, because Object will change the order\n//       If you need to iterate/traverse, choose Map, because it is an iterable object by default, and iterating is more convenient\n// Use Object:\n//       When it’s just a simple data structure, choose Object, because it occupies less memory when there is less data and is more efficient when creating a new one.\n//       When you need to use JSON for file transfer, select Object, because JSON does not support Map by default\n//       When you need to perform operations on multiple key values, choose Object because the syntax is more concise\n//       When you need to override the key on the prototype, select Object\n\n// 1e+7\n// let arr2 = Object.assign([],arr)             4703\n// for loop map.set(j, true)                    2607\n// arr = [];arr[i] = 0                          611\n// obj = {};obj[i] = 0                          607\n// let arr3 = JSON.parse(JSON.stringify(arr))   641\n// arr.toString()                               393\n// JSON.stringify(arr)                          316\n// sort                                         236\n// for loop push                                124\n// [...nums]                                    28\n// for loop =                                   38\n// arr[i] = 0                                   34\n// obj[i] = 0                                   15\n// reverse                                      8\n// indexOf half                                 8\n// arr.push(0)                                  117\n// new Array(1e+7).fill(0);                     50\n\n// 1e+8\n// arr.push(0)                                  878\n// new Array(1e+8).fill(0);                     19191\n\n// const arr = [];\n// const obj: {[key in number]: number} = {};\n// let x;\n// const map = new Map<number,boolean>()\n// const time0 = timeStart();\n// for (let i = 1e+7; i > 0; i--) {\n//     arr.push(i);\n// }\n// timeEnd(time0, 'for loop push');\n//\n// const time1 = timeStart();\n// x = [...arr]\n// timeEnd(time1, '[...nums]');\n//\n// const time2 = timeStart();\n// const sorted = arr.sort((a, b) => b - a);\n// timeEnd(time2, 'sorted')\n//\n// const time3 = timeStart();\n// const reversed = arr.reverse();\n// timeEnd(time3, 'reverse')\n//\n// const time4 = timeStart();\n// const indexOfHalf = arr.indexOf(5e+6);\n// timeEnd(time4, 'indexOf half')\n//\n// const time5 = timeStart();\n// for (let i = 1e+7; i > 0; i--) {\n//     map.set(i, false);\n// }\n// timeEnd(time5, 'map.set(i, true)')\n//\n// const time6 = timeStart();\n// for (let i = 1e+7; i > 0; i--) {\n//     arr[i] = 0;\n// }\n// timeEnd(time6, 'arr[i] = 0')\n//\n// const time7 = timeStart();\n// for (let i = 1e+7; i > 0; i--) {\n//     obj[i] = 0;\n// }\n// timeEnd(time7, 'obj[i] = 0')\n//\n// const time8 = timeStart();\n// x = [...arr];\n// timeEnd(time8, '[...arr] ')\n//\n// let time9 = timeStart();\n// let arr1 = [...arr];\n// timeEnd(time9, '[...arr] sorted')\n//\n// let time10  = timeStart();\n// let arr2 = Object.assign([],arr);\n// timeEnd(time10, 'Object.assign([],arr)')\n//\n// let time11 = timeStart();\n// let arr3 = JSON.parse(JSON.stringify(arr));\n// timeEnd(time11, 'JSON.parse(JSON.stringify(arr))')\n\n\n// Stack Exceed Size\n// Internet Explorer\n// IE6: 1130\n// IE7: 2553\n// IE8: 1475\n// IE9: 20678\n// IE10: 20677\n// Mozilla Firefox\n// 3.6: 3000\n// 4.0: 9015\n// 5.0: 9015\n// 6.0: 9015\n// 7.0: 65533\n// 8b3: 63485\n// 17: 50762\n// 18: 52596\n// 19: 52458\n// 42: 281810\n// Google Chrome\n// 14: 26177\n// 15: 26168\n// 16: 26166\n// 25: 25090\n// 47: 20878\n// 51: 41753\n// Safari\n// 4: 52426\n// 5: 65534\n// 9: 63444\n// Opera\n// 10.10: 9999\n// 10.62: 32631\n// 11: 32631\n// 12: 32631\n// Edge\n// 87: 13970\n\n// Algorithm        Time Complexity\t                                    Space Complexity    stability\n//                  Best\t        Average\t         Worst\t            Worst\n// Quicksort\t    Ω(n log(n))\t    Θ(n log(n))\t     O(n^2)\t            O(log(n))           false\n// Mergesort\t    Ω(n log(n))\t    Θ(n log(n))\t     O(n log(n))\t    O(n)                true\n// Timsort\t        Ω(n)\t        Θ(n log(n))\t     O(n log(n))\t    O(n)\n// Heapsort\t        Ω(n log(n))\t    Θ(n log(n))\t     O(n log(n))\t    O(1)                false\n// Bubble Sort\t    Ω(n)\t        Θ(n^2)\t         O(n^2)\t            O(1)                true\n// Insertion Sort\tΩ(n)\t        Θ(n^2)\t         O(n^2)\t            O(1)                true\n// Selection Sort\tΩ(n^2)\t        Θ(n^2)\t         O(n^2)\t            O(1)                false\n// Tree Sort\t    Ω(n log(n))\t    Θ(n log(n))\t     O(n^2)\t            O(n)\n// Shell Sort\t    Ω(n log(n))\t    Θ(n(log(n))^2)\t O(n(log(n))^2)\t    O(1)\n// Bucket Sort\t    Ω(n+k)\t        Θ(n+k)\t         O(n^2)\t            O(n)                true\n// Radix Sort\t    Ω(nk)\t        Θ(nk)\t         O(nk)\t            O(n+k)\n// Counting Sort\tΩ(n+k)\t        Θ(n+k)\t         O(n+k)\t            O(k)\n// Cubesort     \tΩ(n)\t        Θ(n log(n))\t     O(n log(n))\t    O(n)\n\n\n// Data Structure\t    Time Complexity                                         \t                                    Space Complexity\n//                      Average\t                        Worst\t                                                        Worst\n//                      Access\t    Search\t    Insertion\tDeletion\tAccess\t    Search\t    Insertion\tDeletion\n// Array\t            Θ(1)\t    Θ(n)\t    Θ(n)\t    Θ(n)\t    O(1)\t    O(n)\t    O(n)\t    O(n)\t    O(n)\n// Stack\t            Θ(n)\t    Θ(n)\t    Θ(1)\t    Θ(1)\t    O(n)\t    O(n)\t    O(1)\t    O(1)\t    O(n)\n// Queue\t            Θ(n)\t    Θ(n)\t    Θ(1)\t    Θ(1)\t    O(n)\t    O(n)\t    O(1)\t    O(1)\t    O(n)\n// Singly-Linked List\tΘ(n)\t    Θ(n)\t    Θ(1)\t    Θ(1)\t    O(n)\t    O(n)\t    O(1)\t    O(1)\t    O(n)\n// Doubly-Linked List\tΘ(n)\t    Θ(n)\t    Θ(1)\t    Θ(1)\t    O(n)\t    O(n)\t    O(1)\t    O(1)\t    O(n)\n// Skip List\t        Θ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(n)\t    O(n)\t    O(n)\t    O(n)\t    O(n log(n))\n// Hash Table\t        N/A\t        Θ(1)\t    Θ(1)\t    Θ(1)\t    N/A     \tO(n)\t    O(n)\t    O(n)\t    O(n)\n// Binary Search Tree\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(n)\t    O(n)\t    O(n)\t    O(n)\t    O(n)\n// Cartesian Tree   \tN/A \t    Θ(log(n))\tΘ(log(n))\tΘ(log(n))\tN/A\t        O(n)    \tO(n)\t    O(n)\t    O(n)\n// B-Tree           \tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(n)\n// Red-Black Tree   \tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(n)\n// Splay Tree       \tN/A \t    Θ(log(n))\tΘ(log(n))\tΘ(log(n))\tN/A\t        O(log(n))\tO(log(n))\tO(log(n))\tO(n)\n// AVL Tree\t            Θ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(log(n))\tO(n)\n// KD Tree\t            Θ(log(n))\tΘ(log(n))\tΘ(log(n))\tΘ(log(n))\tO(n)\t    O(n)\t    O(n)\t    O(n)\t    O(n)\n\nexport const runAlgorithm = async (algorithm: Function, output: boolean | 'stringify' = true, ...args: any) => {\n    const startTime = timeStart();\n    const result = await algorithm(...args);\n    const timeSpent = (performance ? performance.now() : new Date().getTime()) - startTime;\n    bunnyConsole.log(algorithm.name, 'result -> ', output === 'stringify' ? JSON.stringify(result) : output ? result : '', 'time spent -> ', timeSpent.toFixed(2) + 'ms');\n    return result;\n};\n\nexport const isOneDiffOrdered = (wordA: string, wordB: string) => {\n    let diffCount = 0;\n    for (let i = 0, len = wordA.length; i < len; i++) {\n        if (wordA[i] !== wordB[i]) {\n            diffCount++;\n            if (diffCount > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\nexport const isOneDiffOrderedPieced = (wordA: string, wordB: string) => {\n    for (let i = 0, len = wordA.length; i < len; i++) {\n        for (let j = 0; j < 26; j++) {\n            const piecedWord = wordA.substr(0, i) + String.fromCharCode(97 + j) + wordA.substr(i + 1);\n            if (piecedWord === wordB) {\n                return true;\n            }\n        }\n    }\n    return false;\n};\n\n// export const genOneDiffOrderedPieced = (wordA: string) => {\n//     const result = [];\n//     let temp = [wordA];\n//\n//\n//     while (temp.length > 0) {\n//         const top = temp.shift();\n//         // const indexes = [Math.floor(Math.random() * wordA.length), Math.floor(Math.random() * wordA.length), Math.floor(Math.random() * wordA.length)];\n//         let indexes = top!\n//         for (let i = 0, len = indexes.length; i < len; i++) {\n//             const candidates = [Math.floor(Math.random() * 26), Math.floor(Math.random() * 26), Math.floor(Math.random() * 26)];\n//             for (let j of candidates) {\n//                 const piecedWord = top!.substr(0, i) + String.fromCharCode(97 + j) + top!.substr(i + 1);\n//                 result.push(piecedWord);\n//                 if (i === indexes.length - 1 && j === candidates.length - 1) {\n//                     temp.push(piecedWord);\n//                     break;\n//                 }\n//                 if (result.length > 99) {\n//                     return result;\n//                 }\n//             }\n//         }\n//\n//     }\n//\n//     return result;\n// }\n// runAlgorithm(genOneDiffOrderedPieced,true, 'hit').then()\n\nexport const isOneDiff = (word1: string, word2: string) => {\n    let diffCount = 0;\n    for (let c1 of word1) {\n        if (!word2.includes(c1)) {\n            diffCount++;\n            if (diffCount > 1) {\n                return false;\n            }\n        }\n    }\n    diffCount = 0;\n    for (let c2 of word2) {\n        if (!word1.includes(c2)) {\n            diffCount++;\n            if (diffCount > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n\n\nconst searchInSortedArray = function (nums: number[], target: number) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        // const mid = Math.floor(left + right / 2);\n        const mid = left + Math.floor((right - left) / 2);\n        const midEle = nums[mid];\n        const leftEle = nums[left];\n\n        if (target === midEle) return mid;\n\n        if (target < leftEle) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return -1;\n};\n\n\nexport type Direction = 'up' | 'down' | 'left' | 'right';\n\nexport class Coordinate {\n    y: number;\n    x: number;\n\n    constructor(y: number, x: number) {\n        this.y = y;\n        this.x = x;\n    }\n}\n\nexport const fourthQuadrantMove = (departure: Coordinate, direction: Direction, matrix: number[][], judgeDeadOrDeadCells?: ((destination: Coordinate) => boolean) | Coordinate[]) => {\n    let destinationX: number = departure.x, destinationY: number = departure.y;\n    switch (direction) {\n        case 'up':\n            destinationY = departure.y + 1;\n            break;\n        case 'right':\n            destinationX = departure.x + 1;\n            break;\n        case 'down':\n            destinationY = departure.y - 1;\n            break;\n        case 'left':\n            destinationX = departure.x - 1;\n            break;\n    }\n    const destination = {y: destinationY, x: destinationX};\n\n    if (matrix) {\n        if (destinationY < 0 || destinationY > matrix.length - 1 || destinationX < 0 || destinationX > matrix[destinationY].length - 1) {\n            return undefined;\n        }\n    }\n\n    if (judgeDeadOrDeadCells) {\n        if (judgeDeadOrDeadCells instanceof Function) {\n            if (judgeDeadOrDeadCells(destination)) {\n                return undefined;\n            }\n        } else {\n            for (let deadCell of judgeDeadOrDeadCells) {\n                if (destination.x === deadCell.x && destination.y === deadCell.y) {\n                    return undefined;\n                }\n            }\n        }\n    }\n\n    return destination;\n};\n\nexport type MatrixCell = [number, number]\nexport const fourthQuadrantMoveByIndex = (departure: MatrixCell, direction: Direction, matrix?: Array<Array<number>>, judgeDeadOrDeadCells?: ((destination: MatrixCell) => boolean) | Array<MatrixCell>) => {\n    const directions = {\n        up: [-1, 0],\n        right: [0, 1],\n        down: [1, 0],\n        left: [0, -1]\n    };\n\n    let newRow = departure[0] + directions[direction][0];\n    let newCol = departure[1] + directions[direction][1];\n    const destination: MatrixCell = [newRow, newCol];\n\n    if (matrix) {\n        if (newRow < 0 || newRow > matrix.length - 1 || newCol < 0 || newCol > matrix[newRow].length - 1) {\n            return undefined;\n        }\n    }\n\n\n    if (judgeDeadOrDeadCells) {\n        if (judgeDeadOrDeadCells instanceof Function) {\n            if (judgeDeadOrDeadCells(destination)) {\n                return undefined;\n            }\n        } else {\n            for (let deadCell of judgeDeadOrDeadCells) {\n                if (newRow === deadCell[0] && newCol === deadCell[1]) {\n                    return undefined;\n                }\n            }\n        }\n    }\n\n    return destination;\n};\n\n\nexport const getRouteByParentsHash = (parents: { [key in string]: Coordinate }, leaf: Coordinate, hashFunction: (cell: Coordinate) => string) => {\n    const route: Coordinate[] = [leaf];\n    const value: Coordinate[] = [leaf];\n    while (value.length > 0) {\n        const cur = value.shift();\n        const curParent = parents[hashFunction(cur!)];\n        if (curParent) {\n            value.push(curParent);\n            route.push(curParent);\n        }\n    }\n    return route.reverse();\n};\n\nexport type HorizontalDirection = -1 | 1 | 0;\nexport type VerticalDirection = 1 | -1 | 0;\nexport const getDirectionVector = (from?: Coordinate, to?: Coordinate): { x: HorizontalDirection, y: VerticalDirection } => {\n    if (!from || !to) {\n        return {x: 0, y: 0};\n    }\n    let horizontal: HorizontalDirection;\n    let vertical: VerticalDirection;\n    horizontal = to.x > from.x ? 1 : -1;\n    vertical = to.y > from.y ? 1 : -1;\n    if (to.x === from.x) {\n        horizontal = 0;\n    }\n    if (to.y === from.y) {\n        vertical = 0;\n    }\n    return {x: horizontal, y: vertical};\n};\n"]},"metadata":{},"sourceType":"module"}