{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}import{arrayRemove,uuidV4}from\"../../utils\";import{HeapNode,MinHeap}from\"../heap\";export var AbstractVertex=function(){function AbstractVertex(id){_classCallCheck(this,AbstractVertex);this._id=id;}_createClass(AbstractVertex,[{key:\"id\",get:function get(){return this._id;},set:function set(v){this._id=v;}}]);return AbstractVertex;}();export var AbstractEdge=function(){function AbstractEdge(weight){_classCallCheck(this,AbstractEdge);if(weight===undefined)weight=AbstractEdge.DEFAULT_EDGE_WEIGHT;this._weight=weight;this._hashCode=uuidV4();}_createClass(AbstractEdge,[{key:\"weight\",get:function get(){return this._weight;},set:function set(v){this._weight=v;}},{key:\"hashCode\",get:function get(){return this._hashCode;},set:function set(v){this._hashCode=v;}}]);return AbstractEdge;}();AbstractEdge.DEFAULT_EDGE_WEIGHT=1;export var AbstractGraph=function(){function AbstractGraph(){_classCallCheck(this,AbstractGraph);this._vertices=new Map();}_createClass(AbstractGraph,[{key:\"getVertex\",value:function getVertex(vertexOrId){var vertexId=this.getVertexId(vertexOrId);return this._vertices.get(vertexId)||null;}},{key:\"getVertexId\",value:function getVertexId(vertexOrId){return vertexOrId instanceof AbstractVertex?vertexOrId.id:vertexOrId;}},{key:\"containsVertex\",value:function containsVertex(vertexOrId){return this._vertices.has(this.getVertexId(vertexOrId));}},{key:\"vertexSet\",value:function vertexSet(){return this._vertices;}},{key:\"addVertex\",value:function addVertex(newVertex){if(this.containsVertex(newVertex)){return false;}this._vertices.set(newVertex.id,newVertex);return true;}},{key:\"removeVertex\",value:function removeVertex(vertexOrId){var vertexId=this.getVertexId(vertexOrId);return this._vertices.delete(vertexId);}},{key:\"removeAllVertices\",value:function removeAllVertices(vertices){var removed=[];for(var _iterator=_createForOfIteratorHelperLoose(vertices),_step;!(_step=_iterator()).done;){var _v=_step.value;removed.push(this.removeVertex(_v));}return removed.length>0;}},{key:\"containsEdge\",value:function containsEdge(v1,v2){var edge=this.getEdge(v1,v2);return!!edge;}},{key:\"setEdgeWeight\",value:function setEdgeWeight(srcOrId,destOrId,weight){var edge=this.getEdge(srcOrId,destOrId);if(edge){edge.weight=weight;return true;}else{return false;}}},{key:\"getAllPathsBetween\",value:function getAllPathsBetween(v1,v2){var _this=this;var paths=[];var vertex1=this.getVertex(v1);var vertex2=this.getVertex(v2);if(!(vertex1&&vertex2)){return[];}var dfs=function dfs(cur,dest,visiting,path){visiting.set(cur,true);if(cur===dest){paths.push([vertex1].concat(_toConsumableArray(path)));}var neighbors=_this.getNeighbors(cur);var _loop=function _loop(neighbor){if(!visiting.get(neighbor)){path.push(neighbor);dfs(neighbor,dest,visiting,path);arrayRemove(path,function(vertex){return vertex===neighbor;});}};for(var _iterator2=_createForOfIteratorHelperLoose(neighbors),_step2;!(_step2=_iterator2()).done;){var neighbor=_step2.value;_loop(neighbor);}visiting.set(cur,false);};dfs(vertex1,vertex2,new Map(),[]);return paths;}},{key:\"getPathSumWeight\",value:function getPathSumWeight(path){var sum=0;for(var i=0;i<path.length;i++){var _this$getEdge;sum+=((_this$getEdge=this.getEdge(path[i],path[i+1]))==null?void 0:_this$getEdge.weight)||0;}return sum;}},{key:\"getMinCostBetween\",value:function getMinCostBetween(v1,v2,isWeight){if(isWeight===undefined)isWeight=false;if(isWeight){var allPaths=this.getAllPathsBetween(v1,v2);var min=Infinity;for(var _iterator3=_createForOfIteratorHelperLoose(allPaths),_step3;!(_step3=_iterator3()).done;){var path=_step3.value;min=Math.min(this.getPathSumWeight(path),min);}return min;}else{var vertex2=this.getVertex(v2);var vertex1=this.getVertex(v1);if(!(vertex1&&vertex2)){return null;}var visited=new Map();var queue=[vertex1];visited.set(vertex1,true);var cost=0;while(queue.length>0){for(var i=0;i<queue.length;i++){var cur=queue.shift();if(cur===vertex2){return cost;}var neighbors=this.getNeighbors(cur);for(var _iterator4=_createForOfIteratorHelperLoose(neighbors),_step4;!(_step4=_iterator4()).done;){var neighbor=_step4.value;if(!visited.has(neighbor)){visited.set(neighbor,true);queue.push(neighbor);}}}cost++;}return null;}}},{key:\"getMinPathBetween\",value:function getMinPathBetween(v1,v2,isWeight){var _this2=this;if(isWeight===undefined)isWeight=false;if(isWeight){var allPaths=this.getAllPathsBetween(v1,v2);var min=Infinity;var minIndex=-1;var index=0;for(var _iterator5=_createForOfIteratorHelperLoose(allPaths),_step5;!(_step5=_iterator5()).done;){var path=_step5.value;var pathSumWeight=this.getPathSumWeight(path);if(pathSumWeight<min){min=pathSumWeight;minIndex=index;}index++;}return allPaths[minIndex]||null;}else{var minPath=[];var vertex1=this.getVertex(v1);var vertex2=this.getVertex(v2);if(!(vertex1&&vertex2)){return[];}var dfs=function dfs(cur,dest,visiting,path){visiting.set(cur,true);if(cur===dest){minPath=[vertex1].concat(_toConsumableArray(path));return;}var neighbors=_this2.getNeighbors(cur);var _loop2=function _loop2(neighbor){if(!visiting.get(neighbor)){path.push(neighbor);dfs(neighbor,dest,visiting,path);arrayRemove(path,function(vertex){return vertex===neighbor;});}};for(var _iterator6=_createForOfIteratorHelperLoose(neighbors),_step6;!(_step6=_iterator6()).done;){var neighbor=_step6.value;_loop2(neighbor);}visiting.set(cur,false);};dfs(vertex1,vertex2,new Map(),[]);return minPath;}}},{key:\"dijkstraWithoutHeap\",value:function dijkstraWithoutHeap(src,dest,getMinDist,genPaths){if(getMinDist===undefined)getMinDist=false;if(genPaths===undefined)genPaths=false;if(dest===undefined)dest=null;var minDist=Infinity;var minDest=null;var minPath=[];var paths=[];var vertices=this._vertices;var distMap=new Map();var seen=new Set();var preMap=new Map();var srcVertex=this.getVertex(src);var destVertex=dest?this.getVertex(dest):null;if(!srcVertex){return null;}for(var _iterator7=_createForOfIteratorHelperLoose(vertices),_step7;!(_step7=_iterator7()).done;){var _ref=_step7.value;var _ref2=_slicedToArray(_ref,2);var id=_ref2[0];var _v2=_ref2[1];distMap.set(_v2,Infinity);}distMap.set(srcVertex,0);preMap.set(srcVertex,null);var getMinOfNoSeen=function getMinOfNoSeen(){var min=Infinity;var minV=null;for(var _iterator8=_createForOfIteratorHelperLoose(distMap),_step8;!(_step8=_iterator8()).done;){var _ref3=_step8.value;var _ref4=_slicedToArray(_ref3,2);var key=_ref4[0];var val=_ref4[1];if(!seen.has(key)){if(val<min){min=val;minV=key;}}}return minV;};var getPaths=function getPaths(minV){for(var _iterator9=_createForOfIteratorHelperLoose(vertices),_step9;!(_step9=_iterator9()).done;){var _ref5=_step9.value;var _ref6=_slicedToArray(_ref5,2);var _id=_ref6[0];var _v3=_ref6[1];var path=[_v3];var parent=preMap.get(_v3);while(parent){path.push(parent);parent=preMap.get(parent);}var reversed=path.reverse();if(_v3===minV)minPath=reversed;paths.push(reversed);}};for(var i=1;i<vertices.size;i++){var cur=getMinOfNoSeen();if(cur){seen.add(cur);if(destVertex&&destVertex===cur){if(getMinDist){minDist=distMap.get(destVertex)||Infinity;}if(genPaths){getPaths(destVertex);}return{distMap:distMap,preMap:preMap,seen:seen,paths:paths,minDist:minDist,minPath:minPath};}var neighbors=this.getNeighbors(cur);for(var _iterator10=_createForOfIteratorHelperLoose(neighbors),_step10;!(_step10=_iterator10()).done;){var neighbor=_step10.value;if(!seen.has(neighbor)){var _edge=this.getEdge(cur,neighbor);if(_edge){if(_edge.weight+distMap.get(cur)<distMap.get(neighbor)){distMap.set(neighbor,_edge.weight+distMap.get(cur));preMap.set(neighbor,cur);}}}}}}getMinDist&&distMap.forEach(function(d,v){if(v!==srcVertex){if(d<minDist){minDist=d;if(genPaths)minDest=v;}}});genPaths&&getPaths(minDest);return{distMap:distMap,preMap:preMap,seen:seen,paths:paths,minDist:minDist,minPath:minPath};}},{key:\"dijkstra\",value:function dijkstra(src,dest,getMinDist,genPaths){if(getMinDist===undefined)getMinDist=false;if(genPaths===undefined)genPaths=false;if(dest===undefined)dest=null;var minDist=Infinity;var minDest=null;var minPath=[];var paths=[];var vertices=this._vertices;var distMap=new Map();var seen=new Set();var preMap=new Map();var srcVertex=this.getVertex(src);var destVertex=dest?this.getVertex(dest):null;if(!srcVertex){return null;}for(var _iterator11=_createForOfIteratorHelperLoose(vertices),_step11;!(_step11=_iterator11()).done;){var _ref7=_step11.value;var _ref8=_slicedToArray(_ref7,2);var id=_ref8[0];var _v4=_ref8[1];distMap.set(_v4,Infinity);}var heap=new MinHeap();heap.insert(new HeapNode(0,srcVertex));distMap.set(srcVertex,0);preMap.set(srcVertex,null);var getPaths=function getPaths(minV){for(var _iterator12=_createForOfIteratorHelperLoose(vertices),_step12;!(_step12=_iterator12()).done;){var _ref9=_step12.value;var _ref10=_slicedToArray(_ref9,2);var _id2=_ref10[0];var _v5=_ref10[1];var path=[_v5];var parent=preMap.get(_v5);while(parent){path.push(parent);parent=preMap.get(parent);}var reversed=path.reverse();if(_v5===minV)minPath=reversed;paths.push(reversed);}};while(heap.size()>0){var curHeapNode=heap.poll();var dist=curHeapNode==null?void 0:curHeapNode.id;var cur=curHeapNode==null?void 0:curHeapNode.val;if(dist!==undefined&&typeof dist==='number'){if(cur){seen.add(cur);if(destVertex&&destVertex===cur){if(getMinDist){minDist=distMap.get(destVertex)||Infinity;}if(genPaths){getPaths(destVertex);}return{distMap:distMap,preMap:preMap,seen:seen,paths:paths,minDist:minDist,minPath:minPath};}var neighbors=this.getNeighbors(cur);for(var _iterator13=_createForOfIteratorHelperLoose(neighbors),_step13;!(_step13=_iterator13()).done;){var neighbor=_step13.value;if(!seen.has(neighbor)){var _this$getEdge2;var _weight=(_this$getEdge2=this.getEdge(cur,neighbor))==null?void 0:_this$getEdge2.weight;if(typeof _weight==='number'){var distSrcToNeighbor=distMap.get(neighbor);if(distSrcToNeighbor){if(dist+_weight<distSrcToNeighbor){heap.insert(new HeapNode(dist+_weight,neighbor));preMap.set(neighbor,cur);distMap.set(neighbor,dist+_weight);}}}}}}}}if(getMinDist){distMap.forEach(function(d,v){if(v!==srcVertex){if(d<minDist){minDist=d;if(genPaths)minDest=v;}}});}if(genPaths){getPaths(minDest);}return{distMap:distMap,preMap:preMap,seen:seen,paths:paths,minDist:minDist,minPath:minPath};}},{key:\"bellmanFord\",value:function bellmanFord(src,scanNegativeCycle,getMin,genPath){if(getMin===undefined)getMin=false;if(genPath===undefined)genPath=false;var srcVertex=this.getVertex(src);var paths=[];var distMap=new Map();var preMap=new Map();var min=Infinity;var minPath=[];var hasNegativeCycle=undefined;if(scanNegativeCycle)hasNegativeCycle=false;if(!srcVertex)return{hasNegativeCycle:hasNegativeCycle,distMap:distMap,preMap:preMap,paths:paths,min:min,minPath:minPath};var vertices=this._vertices;var numOfVertices=vertices.size;var edges=this.edgeSet();var numOfEdges=edges.length;this._vertices.forEach(function(vertex){distMap.set(vertex,Infinity);});distMap.set(srcVertex,0);for(var i=1;i<numOfVertices;++i){for(var j=0;j<numOfEdges;++j){var ends=this.getEndsOfEdge(edges[j]);if(ends){var _ends=_slicedToArray(ends,2),s=_ends[0],d=_ends[1];var _weight2=edges[j].weight;var sWeight=distMap.get(s);var dWeight=distMap.get(d);if(sWeight!==undefined&&dWeight!==undefined){if(distMap.get(s)!==Infinity&&sWeight+_weight2<dWeight){distMap.set(d,sWeight+_weight2);genPath&&preMap.set(d,s);}}}}}var minDest=null;if(getMin){distMap.forEach(function(d,v){if(v!==srcVertex){if(d<min){min=d;if(genPath)minDest=v;}}});}if(genPath){for(var _iterator14=_createForOfIteratorHelperLoose(vertices),_step14;!(_step14=_iterator14()).done;){var _ref11=_step14.value;var _ref12=_slicedToArray(_ref11,2);var id=_ref12[0];var _v6=_ref12[1];var path=[_v6];var parent=preMap.get(_v6);while(parent!==undefined){path.push(parent);parent=preMap.get(parent);}var reversed=path.reverse();if(_v6===minDest)minPath=reversed;paths.push(reversed);}}for(var _j=0;_j<numOfEdges;++_j){var _ends2=this.getEndsOfEdge(edges[_j]);if(_ends2){var _ends3=_slicedToArray(_ends2,1),_s=_ends3[0];var _weight3=edges[_j].weight;var _sWeight=distMap.get(_s);if(_sWeight){if(_sWeight!==Infinity&&_sWeight+_weight3<_sWeight)hasNegativeCycle=true;}}}return{hasNegativeCycle:hasNegativeCycle,distMap:distMap,preMap:preMap,paths:paths,min:min,minPath:minPath};}},{key:\"floyd\",value:function floyd(){var idAndVertices=_toConsumableArray(this._vertices);var n=idAndVertices.length;var costs=[];var predecessor=[];for(var i=0;i<n;i++){costs[i]=[];predecessor[i]=[];for(var j=0;j<n;j++){predecessor[i][j]=null;}}for(var _i=0;_i<n;_i++){for(var _j2=0;_j2<n;_j2++){var _this$getEdge3;costs[_i][_j2]=((_this$getEdge3=this.getEdge(idAndVertices[_i][1],idAndVertices[_j2][1]))==null?void 0:_this$getEdge3.weight)||Infinity;}}for(var k=0;k<n;k++){for(var _i2=0;_i2<n;_i2++){for(var _j3=0;_j3<n;_j3++){if(costs[_i2][_j3]>costs[_i2][k]+costs[k][_j3]){costs[_i2][_j3]=costs[_i2][k]+costs[k][_j3];predecessor[_i2][_j3]=idAndVertices[k][1];}}}}return{costs:costs,predecessor:predecessor};}},{key:\"tarjan\",value:function tarjan(needArticulationPoints,needBridges,needSCCs,needCycles){var _this3=this;var defaultConfig=false;if(needArticulationPoints===undefined)needArticulationPoints=defaultConfig;if(needBridges===undefined)needBridges=defaultConfig;if(needSCCs===undefined)needSCCs=defaultConfig;if(needCycles===undefined)needCycles=defaultConfig;var dfnMap=new Map();var lowMap=new Map();var vertices=this._vertices;vertices.forEach(function(v){dfnMap.set(v,-1);lowMap.set(v,Infinity);});var _vertices$values=vertices.values(),_vertices$values2=_slicedToArray(_vertices$values,1),root=_vertices$values2[0];var articulationPoints=[];var bridges=[];var dfn=0;var dfs=function dfs(cur,parent){dfn++;dfnMap.set(cur,dfn);lowMap.set(cur,dfn);var neighbors=_this3.getNeighbors(cur);var childCount=0;for(var _iterator15=_createForOfIteratorHelperLoose(neighbors),_step15;!(_step15=_iterator15()).done;){var neighbor=_step15.value;if(neighbor!==parent){if(dfnMap.get(neighbor)===-1){childCount++;dfs(neighbor,cur);}var childLow=lowMap.get(neighbor);var curLow=lowMap.get(cur);lowMap.set(cur,Math.min(curLow,childLow));if(needArticulationPoints){if(cur===root&&childCount>=2||cur!==root&&childLow>=dfnMap.get(cur)){articulationPoints.push(cur);}}if(needBridges){if(childLow>dfnMap.get(cur)){bridges.push(_this3.getEdge(cur,neighbor));}}}}};dfs(root,null);var SCCs=new Map();var getSCCs=function getSCCs(){var SCCs=new Map();lowMap.forEach(function(low,vertex){if(!SCCs.has(low)){SCCs.set(low,[vertex]);}else{var _SCCs$get;(_SCCs$get=SCCs.get(low))==null?void 0:_SCCs$get.push(vertex);}});return SCCs;};if(needSCCs){SCCs=getSCCs();}var cycles=new Map();if(needCycles){var _SCCs=new Map();if(_SCCs.size<1){_SCCs=getSCCs();}_SCCs.forEach(function(SCC,low){if(SCC.length>1){cycles.set(low,SCC);}});}return{dfnMap:dfnMap,lowMap:lowMap,bridges:bridges,articulationPoints:articulationPoints,SCCs:SCCs,cycles:cycles};}},{key:\"unionFind\",value:function unionFind(){}}]);return AbstractGraph;}();","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/data-structures/graph/abstract-graph.ts"],"names":["AbstractVertex","AbstractEdge","weight","uuidV4","DEFAULT_EDGE_WEIGHT","AbstractGraph","vertexId","vertexOrId","newVertex","removed","v","edge","paths","vertex1","vertex2","dfs","visiting","cur","neighbors","neighbor","path","arrayRemove","vertex","sum","i","isWeight","allPaths","min","Math","visited","queue","cost","minIndex","index","pathSumWeight","minPath","getMinDist","genPaths","dest","minDist","minDest","vertices","distMap","seen","preMap","srcVertex","destVertex","id","getMinOfNoSeen","minV","key","val","getPaths","parent","reversed","d","heap","curHeapNode","dist","distSrcToNeighbor","getMin","genPath","hasNegativeCycle","numOfVertices","edges","numOfEdges","j","ends","s","sWeight","dWeight","idAndVertices","n","costs","predecessor","k","defaultConfig","needArticulationPoints","needBridges","needSCCs","needCycles","dfnMap","lowMap","root","articulationPoints","bridges","dfn","childCount","childLow","curLow","SCCs","getSCCs","cycles","SCC"],"mappings":"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","sourcesContent":["import {arrayRemove, uuidV4} from '../../utils';\nimport {HeapNode, MinHeap} from '../heap';\n\nexport type VertexId = string | number;\nexport type DijkstraResult<V> =\n    { distMap: Map<V, number>, preMap: Map<V, V | null>, seen: Set<V>, paths: V[][], minDist: number, minPath: V[] }\n    | null;\n\nexport interface I_Graph<V, E> {\n\n    containsVertex(vertexOrId: V | VertexId): boolean;\n\n    getVertex(vertexOrId: VertexId | V): V | null;\n\n    getVertexId(vertexOrId: V | VertexId): VertexId;\n\n    vertexSet(): Map<VertexId, V>;\n\n    addVertex(v: V): boolean;\n\n    removeVertex(vertexOrId: V | VertexId): boolean;\n\n    removeAllVertices(vertices: V[] | VertexId[]): boolean;\n\n    degreeOf(vertexOrId: V | VertexId): number;\n\n    edgesOf(vertexOrId: V | VertexId): E[];\n\n    containsEdge(src: V | VertexId, dest: V | VertexId): boolean;\n\n    // containsEdge(e: E): boolean;\n\n    getEdge(srcOrId: V | VertexId, destOrId: V | VertexId): E | null;\n\n    // getAllEdges(src: V, dest: V): E[];\n\n    edgeSet(): E[];\n\n    addEdge(edge: E): boolean;\n\n    removeEdgeBetween(srcOrId: V | VertexId, destOrId: V | VertexId): E | null;\n\n    removeEdge(edge: E): E | null;\n\n    // removeAllEdges(v1: VertexId | V, v2: VertexId | V): (E | null)[];\n\n    // removeAllEdges(edges: E[] | [VertexId, VertexId]): boolean;\n\n    setEdgeWeight(srcOrId: V | VertexId, destOrId: V | VertexId, weight: number): boolean;\n\n    getMinPathBetween(v1: V | VertexId, v2: V | VertexId, isWeight?: boolean): V[] | null;\n\n    getNeighbors(vertexOrId: V | VertexId): V[];\n}\n\nexport class AbstractVertex {\n    private _id: VertexId;\n    public get id(): VertexId {\n        return this._id;\n    }\n\n    public set id(v: VertexId) {\n        this._id = v;\n    }\n\n    constructor(id: VertexId) {\n        this._id = id;\n    }\n}\n\nexport abstract class AbstractEdge {\n\n    private _weight: number;\n    get weight(): number {\n        return this._weight;\n    }\n\n    set weight(v: number) {\n        this._weight = v;\n    }\n\n    private _hashCode: string;\n\n    get hashCode(): string {\n        return this._hashCode;\n    }\n\n    set hashCode(v: string) {\n        this._hashCode = v;\n    }\n\n    protected constructor(weight?: number) {\n        if (weight === undefined) weight = AbstractEdge.DEFAULT_EDGE_WEIGHT;\n        this._weight = weight;\n        this._hashCode = uuidV4();\n    }\n\n    static DEFAULT_EDGE_WEIGHT: number = 1;\n}\n\n// Connected Component === Largest Connected Sub-Graph\nexport abstract class AbstractGraph<V extends AbstractVertex, E extends AbstractEdge> implements I_Graph<V, E> {\n\n    protected constructor() {\n    }\n\n    protected _vertices: Map<VertexId, V> = new Map<VertexId, V>();\n\n    abstract removeEdgeBetween(srcOrId: V | VertexId, destOrId: V | VertexId): E | null;\n\n    abstract removeEdge(edge: E): E | null;\n\n    getVertex(vertexOrId: VertexId | V): V | null {\n        const vertexId = this.getVertexId(vertexOrId);\n        return this._vertices.get(vertexId) || null;\n    }\n\n    getVertexId(vertexOrId: V | VertexId): VertexId {\n        return vertexOrId instanceof AbstractVertex ? vertexOrId.id : vertexOrId;\n    }\n\n    containsVertex(vertexOrId: V | VertexId): boolean {\n        return this._vertices.has(this.getVertexId(vertexOrId));\n    }\n\n    vertexSet(): Map<VertexId, V> {\n        return this._vertices;\n    }\n\n    abstract getEdge(srcOrId: V | null | VertexId, destOrId: V | null | VertexId): E | null;\n\n    addVertex(newVertex: V): boolean {\n        if (this.containsVertex(newVertex)) {\n            return false;\n        }\n        this._vertices.set(newVertex.id, newVertex);\n        return true;\n    }\n\n    removeVertex(vertexOrId: V | VertexId): boolean {\n        const vertexId = this.getVertexId(vertexOrId);\n        return this._vertices.delete(vertexId);\n    }\n\n    removeAllVertices(vertices: V[] | VertexId[]): boolean {\n        let removed: boolean[] = [];\n        for (let v of vertices) {\n            removed.push(this.removeVertex(v));\n        }\n        return removed.length > 0;\n    }\n\n    abstract degreeOf(vertexOrId: V | VertexId): number;\n\n    abstract edgeSet(): E[];\n\n    abstract edgesOf(vertexOrId: V | VertexId): E[];\n\n    containsEdge(v1: VertexId | V, v2: VertexId | V): boolean {\n        const edge = this.getEdge(v1, v2);\n        return !!edge;\n    }\n\n    abstract addEdge(edge: E): boolean;\n\n    setEdgeWeight(srcOrId: VertexId | V, destOrId: VertexId | V, weight: number): boolean {\n        const edge = this.getEdge(srcOrId, destOrId);\n        if (edge) {\n            edge.weight = weight;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    abstract getNeighbors(vertexOrId: V | VertexId): V[];\n\n    getAllPathsBetween(v1: V | VertexId, v2: V | VertexId): V[][] {\n        let paths: V[][] = [];\n        const vertex1 = this.getVertex(v1);\n        const vertex2 = this.getVertex(v2);\n        if (!(vertex1 && vertex2)) {\n            return [];\n        }\n\n        const dfs = (cur: V, dest: V, visiting: Map<V, boolean>, path: V[]) => {\n            visiting.set(cur, true);\n\n            if (cur === dest) {\n                paths.push([vertex1, ...path]);\n            }\n\n            const neighbors = this.getNeighbors(cur);\n            for (let neighbor of neighbors) {\n                if (!visiting.get(neighbor)) {\n                    path.push(neighbor);\n                    dfs(neighbor, dest, visiting, path);\n                    arrayRemove(path, vertex => vertex === neighbor);\n                }\n            }\n\n            visiting.set(cur, false);\n        };\n\n        dfs(vertex1, vertex2, new Map<V, boolean>(), []);\n        return paths;\n    }\n\n\n    getPathSumWeight(path: V[]): number {\n        let sum = 0;\n        for (let i = 0; i < path.length; i++) {\n            sum += this.getEdge(path[i], path[i + 1])?.weight || 0;\n        }\n        return sum;\n    }\n\n    getMinCostBetween(v1: V | VertexId, v2: V | VertexId, isWeight?: boolean): number | null {\n        if (isWeight === undefined) isWeight = false;\n\n        if (isWeight) {\n            const allPaths = this.getAllPathsBetween(v1, v2);\n            let min = Infinity;\n            for (let path of allPaths) {\n                min = Math.min(this.getPathSumWeight(path), min);\n            }\n            return min;\n        } else {\n            // BFS\n            const vertex2 = this.getVertex(v2);\n            const vertex1 = this.getVertex(v1);\n            if (!(vertex1 && vertex2)) {\n                return null;\n            }\n\n            const visited: Map<V, boolean> = new Map();\n            const queue: V[] = [vertex1];\n            visited.set(vertex1, true);\n            let cost = 0;\n            while (queue.length > 0) {\n                for (let i = 0; i < queue.length; i++) {\n                    const cur = queue.shift();\n                    if (cur === vertex2) {\n                        return cost;\n                    }\n                    // TODO consider optimizing to AbstractGraph\n                    const neighbors = this.getNeighbors(cur!);\n                    for (let neighbor of neighbors) {\n                        if (!visited.has(neighbor)) {\n                            visited.set(neighbor, true);\n                            queue.push(neighbor);\n                        }\n                    }\n                }\n                cost++;\n            }\n            return null;\n        }\n    }\n\n    getMinPathBetween(v1: V | VertexId, v2: V | VertexId, isWeight?: boolean): V[] | null {\n        if (isWeight === undefined) isWeight = false;\n\n        if (isWeight) {\n            const allPaths = this.getAllPathsBetween(v1, v2);\n            let min = Infinity;\n            let minIndex = -1;\n            let index = 0;\n            for (let path of allPaths) {\n                const pathSumWeight = this.getPathSumWeight(path);\n                if (pathSumWeight < min) {\n                    min = pathSumWeight;\n                    minIndex = index;\n                }\n                index++;\n            }\n            return allPaths[minIndex] || null;\n        } else {\n            // BFS\n            let minPath: V[] = [];\n            const vertex1 = this.getVertex(v1);\n            const vertex2 = this.getVertex(v2);\n            if (!(vertex1 && vertex2)) {\n                return [];\n            }\n\n            const dfs = (cur: V, dest: V, visiting: Map<V, boolean>, path: V[]) => {\n                visiting.set(cur, true);\n\n                if (cur === dest) {\n                    minPath = [vertex1, ...path];\n                    return;\n                }\n\n                const neighbors = this.getNeighbors(cur);\n                for (let neighbor of neighbors) {\n                    if (!visiting.get(neighbor)) {\n                        path.push(neighbor);\n                        dfs(neighbor, dest, visiting, path);\n                        arrayRemove(path, vertex => vertex === neighbor);\n                    }\n                }\n\n                visiting.set(cur, false);\n            };\n\n            dfs(vertex1, vertex2, new Map<V, boolean>(), []);\n            return minPath;\n        }\n    }\n\n    /**\n     * Dijkstra algorithm time: O(VE) space: O(V + E)\n     * @param src\n     * @param dest\n     * @param getMinDist\n     * @param genPaths\n     */\n    dijkstraWithoutHeap(src: V | VertexId, dest?: V | VertexId | null, getMinDist?: boolean, genPaths?: boolean): DijkstraResult<V> {\n        if (getMinDist === undefined) getMinDist = false;\n        if (genPaths === undefined) genPaths = false;\n\n        if (dest === undefined) dest = null;\n        let minDist = Infinity;\n        let minDest: V | null = null;\n        let minPath: V[] = [];\n        const paths: V[][] = [];\n\n        const vertices = this._vertices;\n        const distMap: Map<V, number> = new Map();\n        const seen: Set<V> = new Set();\n        const preMap: Map<V, V | null> = new Map(); // predecessor\n        const srcVertex = this.getVertex(src);\n\n        const destVertex = dest ? this.getVertex(dest) : null;\n\n        if (!srcVertex) {\n            return null;\n        }\n\n        for (let [id, v] of vertices) {\n            distMap.set(v, Infinity);\n        }\n        distMap.set(srcVertex, 0);\n        preMap.set(srcVertex, null);\n\n        const getMinOfNoSeen = () => {\n            let min = Infinity;\n            let minV: V | null = null;\n            for (let [key, val] of distMap) {\n                if (!seen.has(key)) {\n                    if (val < min) {\n                        min = val;\n                        minV = key;\n                    }\n                }\n            }\n            return minV;\n        };\n\n        const getPaths = (minV: V | null) => {\n            for (let [id, v] of vertices) {\n                const path: V[] = [v];\n                let parent = preMap.get(v);\n                while (parent) {\n                    path.push(parent);\n                    parent = preMap.get(parent);\n                }\n                const reversed = path.reverse();\n                if (v === minV) minPath = reversed;\n                paths.push(reversed);\n            }\n        };\n\n        for (let i = 1; i < vertices.size; i++) {\n            const cur = getMinOfNoSeen();\n            if (cur) {\n                seen.add(cur);\n                if (destVertex && destVertex === cur) {\n                    if (getMinDist) {\n                        minDist = distMap.get(destVertex) || Infinity;\n                    }\n                    if (genPaths) {\n                        getPaths(destVertex);\n                    }\n                    return {distMap, preMap, seen, paths, minDist, minPath};\n                }\n                const neighbors = this.getNeighbors(cur);\n                for (let neighbor of neighbors) {\n                    if (!seen.has(neighbor)) {\n                        const edge = this.getEdge(cur, neighbor);\n                        if (edge) {\n                            if (edge.weight + distMap.get(cur)! < distMap.get(neighbor)!) {\n                                distMap.set(neighbor, edge.weight + distMap.get(cur)!);\n                                preMap.set(neighbor, cur);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        getMinDist && distMap.forEach((d, v) => {\n            if (v !== srcVertex) {\n                if (d < minDist) {\n                    minDist = d;\n                    if (genPaths) minDest = v;\n                }\n            }\n        });\n\n        genPaths && getPaths(minDest);\n\n        return {distMap, preMap, seen, paths, minDist, minPath};\n    }\n\n\n    /**\n     * Dijkstra algorithm time: O(logVE) space: O(V + E)\n     * @param src\n     * @param dest\n     * @param getMinDist\n     * @param genPaths\n     */\n    dijkstra(src: V | VertexId, dest?: V | VertexId | null, getMinDist?: boolean, genPaths?: boolean): DijkstraResult<V> {\n        if (getMinDist === undefined) getMinDist = false;\n        if (genPaths === undefined) genPaths = false;\n\n        if (dest === undefined) dest = null;\n        let minDist = Infinity;\n        let minDest: V | null = null;\n        let minPath: V[] = [];\n        const paths: V[][] = [];\n        const vertices = this._vertices;\n        const distMap: Map<V, number> = new Map();\n        const seen: Set<V> = new Set();\n        const preMap: Map<V, V | null> = new Map(); // predecessor\n\n        const srcVertex = this.getVertex(src);\n        const destVertex = dest ? this.getVertex(dest) : null;\n\n        if (!srcVertex) {\n            return null;\n        }\n\n        for (let [id, v] of vertices) {\n            distMap.set(v, Infinity);\n        }\n\n        const heap = new MinHeap<HeapNode<V>, V>();\n        heap.insert(new HeapNode(0, srcVertex));\n\n        distMap.set(srcVertex, 0);\n        preMap.set(srcVertex, null);\n\n        const getPaths = (minV: V | null) => {\n            for (let [id, v] of vertices) {\n                const path: V[] = [v];\n                let parent = preMap.get(v);\n                while (parent) {\n                    path.push(parent);\n                    parent = preMap.get(parent);\n                }\n                const reversed = path.reverse();\n                if (v === minV) minPath = reversed;\n                paths.push(reversed);\n            }\n        };\n\n        while (heap.size() > 0) {\n            const curHeapNode = heap.poll();\n            const dist = curHeapNode?.id;\n            const cur = curHeapNode?.val;\n            if (dist !== undefined && typeof dist === 'number') {\n                if (cur) {\n                    seen.add(cur);\n                    if (destVertex && destVertex === cur) {\n                        if (getMinDist) {\n                            minDist = distMap.get(destVertex) || Infinity;\n                        }\n                        if (genPaths) {\n                            getPaths(destVertex);\n                        }\n                        return {distMap, preMap, seen, paths, minDist, minPath};\n                    }\n                    const neighbors = this.getNeighbors(cur);\n                    for (let neighbor of neighbors) {\n                        if (!seen.has(neighbor)) {\n                            const weight = this.getEdge(cur, neighbor)?.weight;\n                            if (typeof weight === 'number') {\n                                const distSrcToNeighbor = distMap.get(neighbor);\n                                if (distSrcToNeighbor) {\n                                    if (dist + weight < distSrcToNeighbor) {\n                                        heap.insert(new HeapNode(dist + weight, neighbor));\n                                        preMap.set(neighbor, cur);\n                                        distMap.set(neighbor, dist + weight);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\n        if (getMinDist) {\n            distMap.forEach((d, v) => {\n                if (v !== srcVertex) {\n                    if (d < minDist) {\n                        minDist = d;\n                        if (genPaths) minDest = v;\n                    }\n                }\n            });\n        }\n\n\n        if (genPaths) {\n            getPaths(minDest);\n        }\n\n\n        return {distMap, preMap, seen, paths, minDist, minPath};\n    }\n\n    abstract getEndsOfEdge(edge: E): [V, V] | null;\n\n\n    /**\n     * BellmanFord time:O(VE) space:O(V)\n     * one to rest pairs\n     * @param src\n     * @param scanNegativeCycle\n     * @param getMin\n     * @param genPath\n     */\n    bellmanFord(src: V | VertexId, scanNegativeCycle?: boolean, getMin?: boolean, genPath?: boolean) {\n        if (getMin === undefined) getMin = false;\n        if (genPath === undefined) genPath = false;\n\n        const srcVertex = this.getVertex(src);\n        const paths: V[][] = [];\n        const distMap: Map<V, number> = new Map();\n        const preMap: Map<V, V> = new Map(); // predecessor\n        let min = Infinity;\n        let minPath: V[] = [];\n        // TODO\n        let hasNegativeCycle: boolean | undefined = undefined;\n        if (scanNegativeCycle) hasNegativeCycle = false;\n        if (!srcVertex) return {hasNegativeCycle, distMap, preMap, paths, min, minPath};\n\n        const vertices = this._vertices;\n        const numOfVertices = vertices.size;\n        const edges = this.edgeSet();\n        const numOfEdges = edges.length;\n\n        this._vertices.forEach(vertex => {\n            distMap.set(vertex, Infinity);\n        });\n\n        distMap.set(srcVertex, 0);\n\n        for (let i = 1; i < numOfVertices; ++i) {\n            for (let j = 0; j < numOfEdges; ++j) {\n                const ends = this.getEndsOfEdge(edges[j]);\n                if (ends) {\n                    const [s, d] = ends;\n                    const weight = edges[j].weight;\n                    const sWeight = distMap.get(s);\n                    const dWeight = distMap.get(d);\n                    if (sWeight !== undefined && dWeight !== undefined) {\n                        if (distMap.get(s) !== Infinity && sWeight + weight < dWeight) {\n                            distMap.set(d, sWeight + weight);\n                            genPath && preMap.set(d, s);\n                        }\n                    }\n                }\n            }\n        }\n\n        let minDest: V | null = null;\n        if (getMin) {\n            distMap.forEach((d, v) => {\n                if (v !== srcVertex) {\n                    if (d < min) {\n                        min = d;\n                        if (genPath) minDest = v;\n                    }\n                }\n            });\n        }\n\n        if (genPath) {\n            for (let [id, v] of vertices) {\n                const path: V[] = [v];\n                let parent = preMap.get(v);\n                while (parent !== undefined) {\n                    path.push(parent);\n                    parent = preMap.get(parent);\n                }\n                const reversed = path.reverse();\n                if (v === minDest) minPath = reversed;\n                paths.push(reversed);\n            }\n        }\n\n        for (let j = 0; j < numOfEdges; ++j) {\n            const ends = this.getEndsOfEdge(edges[j]);\n            if (ends) {\n                const [s] = ends;\n                let weight = edges[j].weight;\n                const sWeight = distMap.get(s);\n                if (sWeight) {\n                    if (sWeight !== Infinity && sWeight + weight < sWeight) hasNegativeCycle = true;\n                }\n            }\n        }\n\n        return {hasNegativeCycle, distMap, preMap, paths, min, minPath};\n    }\n\n    /**\n     * Floyd algorithm time: O(V^3) space: O(V^2), not support graph with negative weight cycle\n     * all pairs\n     */\n    floyd(): { costs: number[][], predecessor: (V | null)[][] } {\n        const idAndVertices = [...this._vertices];\n        const n = idAndVertices.length;\n\n        let costs: number[][] = [];\n        let predecessor: (V | null)[][] = [];\n        // successors\n\n        for (let i = 0; i < n; i++) {\n            costs[i] = [];\n            predecessor[i] = [];\n            for (let j = 0; j < n; j++) {\n                predecessor[i][j] = null;\n            }\n        }\n\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                costs[i][j] = this.getEdge(idAndVertices[i][1], idAndVertices[j][1])?.weight || Infinity;\n            }\n        }\n\n        for (let k = 0; k < n; k++) {\n            for (let i = 0; i < n; i++) {\n                for (let j = 0; j < n; j++) {\n                    if (costs[i][j] > costs[i][k] + costs[k][j]) {\n                        costs[i][j] = costs[i][k] + costs[k][j];\n                        predecessor[i][j] = idAndVertices[k][1];\n                    }\n                }\n            }\n        }\n        return {costs, predecessor};\n\n    }\n\n\n    /**--- start find cycles --- */\n\n    /**\n     * Tarjan is an algorithm based on DFS,which is used to solve the connectivity problem of graphs.\n     * Tarjan can find cycles in directed or undirected graph\n     * Tarjan can find the articulation points and bridges(critical edges) of undirected graphs in linear time,\n     * Tarjan solve the bi-connected components of undirected graphs;\n     * Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.\n     */\n    tarjan(needArticulationPoints?: boolean, needBridges?: boolean, needSCCs?: boolean, needCycles?: boolean) {\n        // !! in undirected graph we will not let child visit parent when DFS\n        // !! articulation point(in DFS search tree not in graph): (cur !== root && cur.has(child)) && (low(child) >= dfn(cur)) || (cur === root && cur.children() >= 2)\n        // !! bridge: low(child) > dfn(cur)\n\n        const defaultConfig = false;\n        if (needArticulationPoints === undefined) needArticulationPoints = defaultConfig;\n        if (needBridges === undefined) needBridges = defaultConfig;\n        if (needSCCs === undefined) needSCCs = defaultConfig;\n        if (needCycles === undefined) needCycles = defaultConfig;\n\n        const dfnMap: Map<V, number> = new Map();\n        const lowMap: Map<V, number> = new Map();\n        const vertices = this._vertices;\n        vertices.forEach(v => {\n            dfnMap.set(v, -1);\n            lowMap.set(v, Infinity);\n        });\n\n        const [root] = vertices.values();\n\n        const articulationPoints: V[] = [];\n        const bridges: E[] = [];\n        let dfn = 0;\n        const dfs = (cur: V, parent: V | null) => {\n            dfn++;\n            dfnMap.set(cur, dfn);\n            lowMap.set(cur, dfn);\n\n            const neighbors = this.getNeighbors(cur);\n            let childCount = 0; // child in DFS tree not child in graph\n            for (let neighbor of neighbors) {\n                if (neighbor !== parent) {\n                    if (dfnMap.get(neighbor) === -1) {\n                        childCount++;\n                        dfs(neighbor, cur);\n                    }\n                    const childLow = lowMap.get(neighbor);\n                    const curLow = lowMap.get(cur);\n                    lowMap.set(cur, Math.min(curLow!, childLow!));\n\n                    if (needArticulationPoints) {\n                        if (cur === root && childCount >= 2 || ((cur !== root) && (childLow! >= dfnMap.get(cur)!))) {\n                            articulationPoints.push(cur);\n                        }\n                    }\n\n                    if (needBridges) {\n                        if (childLow! > dfnMap.get(cur)!) {\n                            bridges.push(this.getEdge(cur, neighbor)!);\n                        }\n                    }\n                }\n            }\n\n        };\n\n        dfs(root, null);\n\n        let SCCs: Map<number, V[]> = new Map();\n\n        const getSCCs = () => {\n            const SCCs: Map<number, V[]> = new Map();\n            lowMap.forEach((low, vertex) => {\n                if (!SCCs.has(low)) {\n                    SCCs.set(low, [vertex]);\n                } else {\n                    SCCs.get(low)?.push(vertex);\n                }\n            });\n            return SCCs;\n        };\n\n        if (needSCCs) {\n            SCCs = getSCCs();\n        }\n\n        const cycles: Map<number, V[]> = new Map();\n        if (needCycles) {\n            let SCCs: Map<number, V[]> = new Map();\n            if (SCCs.size < 1) {\n                SCCs = getSCCs();\n            }\n\n            SCCs.forEach((SCC, low) => {\n                if (SCC.length > 1) {\n                    cycles.set(low, SCC);\n                }\n            });\n        }\n\n        return {dfnMap, lowMap, bridges, articulationPoints, SCCs, cycles};\n    }\n\n\n    unionFind() {\n    }\n\n    /**--- end find cycles --- */\n\n\n    // Minimum Spanning Tree\n}\n"]},"metadata":{},"sourceType":"module"}