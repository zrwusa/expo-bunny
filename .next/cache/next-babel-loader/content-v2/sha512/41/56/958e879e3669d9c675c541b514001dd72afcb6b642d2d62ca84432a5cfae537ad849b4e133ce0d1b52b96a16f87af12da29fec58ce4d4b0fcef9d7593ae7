{"ast":null,"code":"import _construct from\"@babel/runtime/helpers/construct\";import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";function _createForOfIteratorHelperLoose(o,allowArrayLike){var it=typeof Symbol!==\"undefined\"&&o[Symbol.iterator]||o[\"@@iterator\"];if(it)return(it=it.call(o)).next.bind(it);if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}export var SinglyLinkedListNode=function(){function SinglyLinkedListNode(data,prev,next,list){_classCallCheck(this,SinglyLinkedListNode);this.data=data;this.prev=prev;this.next=next;this.list=list;}_createClass(SinglyLinkedListNode,[{key:\"value\",get:function get(){return this.data;}},{key:\"index\",get:function get(){var _this=this;if(!this.list){return undefined;}return this.list.findIndex(function(value){return value===_this.value;});}},{key:\"insertBefore\",value:function insertBefore(data){return this.list!==null?this.list.insertBefore(this,data):new SinglyLinkedList(data,this.data);}},{key:\"insertAfter\",value:function insertAfter(data){return this.list!==null?this.list.insertAfter(this,data):new SinglyLinkedList(this.data,data);}},{key:\"remove\",value:function remove(){if(this.list===null){throw new ReferenceError('Node does not belong to any list');}return this.list.removeNode(this);}}]);return SinglyLinkedListNode;}();export var SinglyLinkedList=function(_Symbol$iterator){function SinglyLinkedList(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_classCallCheck(this,SinglyLinkedList);this.head=null;this.tail=null;this.size=0;for(var i=0;i<arguments.length;i++){this.append(arguments[i]);}}_createClass(SinglyLinkedList,[{key:\"length\",get:function get(){return this.size;}},{key:\"get\",value:function get(index){var node=this.getNode(index);return node!==undefined?node.data:undefined;}},{key:\"getNode\",value:function getNode(index){if(this.head===null||index<0||index>=this.length){return undefined;}var asc=index<this.length/2;var stopAt=asc?index:this.length-index-1;var nextNode=asc?'next':'prev';var currentNode=asc?this.head:this.tail;for(var currentIndex=0;currentIndex<stopAt;currentIndex++){currentNode=currentNode[nextNode];}return currentNode;}},{key:\"findNodeIndex\",value:function findNodeIndex(f){var currentIndex=0;var currentNode=this.head;while(currentNode){if(f(currentNode.data,currentIndex,this)){return{index:currentIndex,node:currentNode};}currentNode=currentNode.next;currentIndex+=1;}return undefined;}},{key:\"findNode\",value:function findNode(f){var nodeIndex=this.findNodeIndex(f);return nodeIndex!==undefined?nodeIndex.node:undefined;}},{key:\"find\",value:function find(f){var nodeIndex=this.findNodeIndex(f);return nodeIndex!==undefined?nodeIndex.node.data:undefined;}},{key:\"findIndex\",value:function findIndex(f){var nodeIndex=this.findNodeIndex(f);return nodeIndex!==undefined?nodeIndex.index:-1;}},{key:\"append\",value:function append(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}for(var _i=0,_args=args;_i<_args.length;_i++){var _data=_args[_i];var node=new SinglyLinkedListNode(_data,this.tail,null,this);if(this.head===null){this.head=node;}if(this.tail!==null){this.tail.next=node;}this.tail=node;this.size+=1;}return this;}},{key:\"push\",value:function push(){this.append.apply(this,arguments);return this.length;}},{key:\"prepend\",value:function prepend(){for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}var reverseArgs=Array.from(args).reverse();for(var _iterator=_createForOfIteratorHelperLoose(reverseArgs),_step;!(_step=_iterator()).done;){var _data2=_step.value;var node=new SinglyLinkedListNode(_data2,null,this.head,this);if(this.tail===null){this.tail=node;}if(this.head!==null){this.head.prev=node;}this.head=node;this.size+=1;}return this;}},{key:\"insertAt\",value:function insertAt(index,data){if(this.head===null){return this.append(data);}if(index<=0){return this.prepend(data);}var currentNode=this.head;var currentIndex=0;while(currentIndex<index-1&&currentNode.next!==null){currentIndex+=1;currentNode=currentNode.next;}currentNode.insertAfter(data);return this;}},{key:\"removeNode\",value:function removeNode(node){if(node.list!==this){throw new ReferenceError('Node does not belong to this list');}if(node.prev!==null){node.prev.next=node.next;}if(node.next!==null){node.next.prev=node.prev;}if(this.head===node){this.head=node.next;}if(this.tail===node){this.tail=node.prev;}this.size-=1;node.next=null;node.prev=null;node.list=null;return node;}},{key:\"removeAt\",value:function removeAt(index){var node=this.getNode(index);return node!==undefined?this.removeNode(node):undefined;}},{key:\"insertBefore\",value:function insertBefore(referenceNode,data){var node=new SinglyLinkedListNode(data,referenceNode.prev,referenceNode,this);if(referenceNode.prev===null){this.head=node;}if(referenceNode.prev!==null){referenceNode.prev.next=node;}referenceNode.prev=node;this.size+=1;return this;}},{key:\"sort\",value:function sort(compare){if(this.head===null||this.tail===null){return this;}if(this.length<2){return this;}var quicksort=function quicksort(start,end){if(start===end){return;}var pivotData=end.data;var current=start;var split=start;while(current&&current!==end){var sort=compare(current.data,pivotData);if(sort){if(current!==split){var temp=split.data;split.data=current.data;current.data=temp;}split=split.next;}current=current.next;}end.data=split.data;split.data=pivotData;if(start.next===end.prev){return;}if(split.prev&&split!==start){quicksort(start,split.prev);}if(split.next&&split!==end){quicksort(split.next,end);}};quicksort(this.head,this.tail);return this;}},{key:\"insertAfter\",value:function insertAfter(referenceNode,data){var node=new SinglyLinkedListNode(data,referenceNode,referenceNode.next,this);if(referenceNode.next===null){this.tail=node;}if(referenceNode.next!==null){referenceNode.next.prev=node;}referenceNode.next=node;this.size+=1;return this;}},{key:\"shift\",value:function shift(){return this.removeFromAnyEnd(this.head);}},{key:\"pop\",value:function pop(){return this.removeFromAnyEnd(this.tail);}},{key:\"merge\",value:function merge(list){if(this.tail!==null){this.tail.next=list.head;}if(list.head!==null){list.head.prev=this.tail;}this.head=this.head||list.head;this.tail=list.tail||this.tail;this.size+=list.size;list.size=this.size;list.head=this.head;list.tail=this.tail;}},{key:\"clear\",value:function clear(){this.head=null;this.tail=null;this.size=0;return this;}},{key:\"slice\",value:function slice(start,end){var list=new SinglyLinkedList();var finish=end;if(this.head===null||this.tail===null){return list;}if(finish===undefined||finish<start){finish=this.length;}var head=this.getNode(start);for(var i=0;i<finish-start&&head!==null&&head!==undefined;i++){list.append(head.data);head=head.next;}return list;}},{key:\"reverse\",value:function reverse(){var currentNode=this.head;while(currentNode){var _next=currentNode.next;currentNode.next=currentNode.prev;currentNode.prev=_next;currentNode=currentNode.prev;}var tail=this.tail;this.tail=this.head;this.head=tail;return this;}},{key:\"forEach\",value:function forEach(f){var reverse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var currentIndex=reverse?this.length-1:0;var currentNode=reverse?this.tail:this.head;var modifier=reverse?-1:1;var nextNode=reverse?'prev':'next';while(currentNode){f(currentNode.data,currentIndex,this);currentNode=currentNode[nextNode];currentIndex+=modifier;}}},{key:\"map\",value:function map(f){var _this2=this;var reverse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var list=new SinglyLinkedList();this.forEach(function(data,index){return list.append(f(data,index,_this2));},reverse);return list;}},{key:\"filter\",value:function filter(f){var _this3=this;var reverse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var list=new SinglyLinkedList();this.forEach(function(data,index){if(f(data,index,_this3)){list.append(data);}},reverse);return list;}},{key:\"reduce\",value:function reduce(f,start){var reverse=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var currentIndex=reverse?this.length-1:0;var modifier=reverse?-1:1;var nextNode=reverse?'prev':'next';var currentElement=reverse?this.tail:this.head;var result;if(start!==undefined){result=start;}else if(currentElement){result=currentElement.data;currentElement=currentElement[nextNode];}else{throw new TypeError('Reduce of empty LinkedList with no initial value');}while(currentElement){result=f(result,currentElement.data,currentIndex,this);currentIndex+=modifier;currentElement=currentElement[nextNode];}return result;}},{key:\"toArray\",value:function toArray(){return _toConsumableArray(this);}},{key:\"toString\",value:function toString(){var separator=arguments.length>0&&arguments[0]!==undefined?arguments[0]:' ';return this.reduce(function(s,data){return\"\"+s+separator+data;});}},{key:_Symbol$iterator,value:_regeneratorRuntime.mark(function value(){var element;return _regeneratorRuntime.wrap(function value$(_context){while(1){switch(_context.prev=_context.next){case 0:element=this.head;case 1:if(!(element!==null)){_context.next=7;break;}_context.next=4;return element.data;case 4:element=element.next;_context.next=1;break;case 7:case\"end\":return _context.stop();}}},value,this);})},{key:\"removeFromAnyEnd\",value:function removeFromAnyEnd(node){return node!==null?this.removeNode(node).data:undefined;}}],[{key:\"from\",value:function from(iterable){return _construct(SinglyLinkedList,_toConsumableArray(iterable));}}]);return SinglyLinkedList;}(Symbol.iterator);","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/data-structures/linked-list/singly-linked-list.ts"],"names":["SinglyLinkedListNode","data","prev","next","list","value","SinglyLinkedList","args","i","arguments","node","index","asc","stopAt","nextNode","currentNode","currentIndex","f","nodeIndex","reverseArgs","Array","referenceNode","quicksort","start","pivotData","end","current","split","sort","compare","temp","finish","head","tail","reverse","modifier","currentElement","result","separator","Symbol","element"],"mappings":"y2CAoBA,MAAA,IAAaA,CAAAA,oBAAb,CAAA,UAAA,CACI,QAAA,CAAA,oBAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,CASE,CAAA,eAAA,CAAA,IAAA,CAAA,oBAAA,CAAA,CAAA,KAPSC,IAOT,CAPSA,IAOT,CAAA,KALSC,IAKT,CALSA,IAKT,CAAA,KAHSC,IAGT,CAHSA,IAGT,CAAA,KADSC,IACT,CADSA,IACT,CACD,CAXL,YAAA,CAAA,oBAAA,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,GAAA,CAmBI,QAAA,CAAA,GAAA,EAAmB,CACf,MAAO,MAAP,IAAA,CACH,CArBL,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,GAAA,CA6BI,QAAA,CAAA,GAAA,EAAmB,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,CACf,GAAI,CAAC,KAAL,IAAA,CAAgB,CACZ,MAAA,CAAA,SAAA,CACH,CACD,MAAO,MAAA,IAAA,CAAA,SAAA,CAAoB,SAAA,KAAA,CAAA,CAAA,MAAWC,CAAAA,KAAK,GAAK,KAAI,CAAzB,KAAA,CAA3B,CAAO,CAAP,CACH,CAlCL,CAAA,CAAA,CAAA,GAAA,CAAA,cAAA,CAAA,KAAA,CA2CI,QAAA,CAAA,YAAA,CAAA,IAAA,CAAgE,CAC5D,MAAO,MAAA,IAAA,GAAA,IAAA,CACD,KAAA,IAAA,CAAA,YAAA,CAAA,IAAA,CADC,IACD,CADC,CAED,GAAA,CAAA,gBAAA,CAAA,IAAA,CAA2B,KAFjC,IAEM,CAFN,CAGH,CA/CL,CAAA,CAAA,CAAA,GAAA,CAAA,aAAA,CAAA,KAAA,CAwDI,QAAA,CAAA,WAAA,CAAA,IAAA,CAA+D,CAC3D,MAAO,MAAA,IAAA,GAAA,IAAA,CACD,KAAA,IAAA,CAAA,WAAA,CAAA,IAAA,CADC,IACD,CADC,CAED,GAAA,CAAA,gBAAA,CAAqB,KAArB,IAAA,CAFN,IAEM,CAFN,CAGH,CA5DL,CAAA,CAAA,CAAA,GAAA,CAAA,QAAA,CAAA,KAAA,CAoEI,QAAA,CAAA,MAAA,EAAgD,CAC5C,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAM,IAAA,CAAA,cAAA,CAAN,kCAAM,CAAN,CACH,CACD,MAAO,MAAA,IAAA,CAAA,UAAA,CAAP,IAAO,CAAP,CACH,CAzEL,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,oBAAA,CAAA,CAAA,EAAA,CAoFA,MAAA,IAAaC,CAAAA,gBAAb,CAAA,SAAA,gBAAA,CAAA,CA8BI,QAAA,CAAA,gBAAA,EAAiC,CAAA,IAAA,GAAA,CAAA,IAAA,CAAA,SAAA,CAAA,MAAA,CAAlBC,IAAkB,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CAAA,IAAA,CAAA,CAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA,EAAA,CAAA,CAAlBA,IAAkB,CAAA,IAAA,CAAlBA,CAAkB,SAAA,CAAA,IAAA,CAAlBA,CAAkB,CAAA,eAAA,CAAA,IAAA,CAAA,gBAAA,CAAA,CAC7B,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,CAAA,CAAA,CAEA,IAAK,GAAIC,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGC,SAAS,CAA7B,MAAA,CAAsCD,CAAtC,EAAA,CAA2C,CACvC,KAAA,MAAA,CAAYC,SAAS,CAArB,CAAqB,CAArB,EACH,CACJ,CAtCL,YAAA,CAAA,gBAAA,CAAA,CAAA,CAAA,GAAA,CAAA,QAAA,CAAA,GAAA,CAKI,QAAA,CAAA,GAAA,EAA4B,CACxB,MAAO,MAAP,IAAA,CACH,CAPL,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,KAAA,CA+CI,QAAA,CAAA,GAAA,CAAA,KAAA,CAAgD,CAC5C,GAAMC,CAAAA,IAAI,CAAG,KAAA,OAAA,CAAb,KAAa,CAAb,CACA,MAAOA,CAAAA,IAAI,GAAJA,SAAAA,CAAqBA,IAAI,CAAzBA,IAAAA,CAAP,SAAA,CACH,CAlDL,CAAA,CAAA,CAAA,GAAA,CAAA,SAAA,CAAA,KAAA,CA2DI,QAAA,CAAA,OAAA,CAAA,KAAA,CAA0E,CACtE,GAAI,KAAA,IAAA,GAAA,IAAA,EAAsBC,KAAK,CAA3B,CAAA,EAAmCA,KAAK,EAAI,KAAhD,MAAA,CAA6D,CACzD,MAAA,CAAA,SAAA,CACH,CACD,GAAMC,CAAAA,GAAG,CAAGD,KAAK,CAAG,KAAA,MAAA,CAApB,CAAA,CACA,GAAME,CAAAA,MAAM,CAAGD,GAAG,CAAA,KAAA,CAAW,KAAA,MAAA,CAAA,KAAA,CAA7B,CAAA,CACA,GAAME,CAAAA,QAAQ,CAAGF,GAAG,CAAA,MAAA,CAApB,MAAA,CACA,GAAIG,CAAAA,WAAW,CAAGH,GAAG,CAAG,KAAH,IAAA,CAAe,KAApC,IAAA,CACA,IAAK,GAAII,CAAAA,YAAY,CAArB,CAAA,CAA2BA,YAAY,CAAvC,MAAA,CAAkDA,YAAlD,EAAA,CAAkE,CAC9DD,WAAW,CAAGA,WAAW,CAAzBA,QAAyB,CAAzBA,CACH,CACD,MAAA,CAAA,WAAA,CACH,CAvEL,CAAA,CAAA,CAAA,GAAA,CAAA,eAAA,CAAA,KAAA,CAkFI,QAAA,CAAA,aAAA,CAAA,CAAA,CAGe,CACX,GAAIC,CAAAA,YAAY,CAAhB,CAAA,CACA,GAAID,CAAAA,WAAW,CAAG,KAAlB,IAAA,CACA,MAAA,WAAA,CAAoB,CAChB,GAAIE,CAAC,CAACF,WAAW,CAAZ,IAAA,CAAA,YAAA,CAAL,IAAK,CAAL,CAA6C,CACzC,MAAO,CACHJ,KAAK,CADF,YAAA,CAEHD,IAAI,CAAEK,WAFH,CAAP,CAIH,CACDA,WAAW,CAAGA,WAAW,CAAzBA,IAAAA,CACAC,YAAY,EAAZA,CAAAA,CACH,CACD,MAAA,CAAA,SAAA,CACH,CAnGL,CAAA,CAAA,CAAA,GAAA,CAAA,UAAA,CAAA,KAAA,CA8GI,QAAA,CAAA,QAAA,CAAA,CAAA,CAAwF,CACpF,GAAME,CAAAA,SAAS,CAAG,KAAA,aAAA,CAAlB,CAAkB,CAAlB,CACA,MAAOA,CAAAA,SAAS,GAATA,SAAAA,CAA0BA,SAAS,CAAnCA,IAAAA,CAAP,SAAA,CACH,CAjHL,CAAA,CAAA,CAAA,GAAA,CAAA,MAAA,CAAA,KAAA,CA2HI,QAAA,CAAA,IAAA,CAAA,CAAA,CAA8D,CAC1D,GAAMA,CAAAA,SAAS,CAAG,KAAA,aAAA,CAAlB,CAAkB,CAAlB,CACA,MAAOA,CAAAA,SAAS,GAATA,SAAAA,CAA0BA,SAAS,CAATA,IAAAA,CAA1BA,IAAAA,CAAP,SAAA,CACH,CA9HL,CAAA,CAAA,CAAA,GAAA,CAAA,WAAA,CAAA,KAAA,CAwII,QAAA,CAAA,SAAA,CAAA,CAAA,CAAqD,CACjD,GAAMA,CAAAA,SAAS,CAAG,KAAA,aAAA,CAAlB,CAAkB,CAAlB,CACA,MAAOA,CAAAA,SAAS,GAATA,SAAAA,CAA0BA,SAAS,CAAnCA,KAAAA,CAA4C,CAAnD,CAAA,CACH,CA3IL,CAAA,CAAA,CAAA,GAAA,CAAA,QAAA,CAAA,KAAA,CAsJI,QAAA,CAAA,MAAA,EAA+D,CAAA,IAAA,GAAA,CAAA,KAAA,CAAA,SAAA,CAAA,MAAA,CAA9CX,IAA8C,CAAA,GAAA,CAAA,KAAA,CAAA,KAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,EAAA,CAAA,CAA9CA,IAA8C,CAAA,KAAA,CAA9CA,CAA8C,SAAA,CAAA,KAAA,CAA9CA,CAA8C,CAC3D,IAAA,GAAA,CAAA,EAAA,CAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,EAAA,CAAA,KAAA,CAAA,MAAA,CAAA,EAAA,EAAA,CAAyB,CAApB,GAAMN,CAAAA,KAAI,CAAA,KAAA,CAAV,EAAU,CAAV,CACD,GAAMS,CAAAA,IAAI,CAAG,GAAA,CAAA,oBAAA,CAAA,KAAA,CAA+B,KAA/B,IAAA,CAAA,IAAA,CAAb,IAAa,CAAb,CACA,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAA,IAAA,CACH,CACD,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAA,IAAA,CAAA,IAAA,CACH,CACD,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,EAAA,CAAA,CACH,CACD,MAAA,KAAA,CACH,CAnKL,CAAA,CAAA,CAAA,GAAA,CAAA,MAAA,CAAA,KAAA,CA4KI,QAAA,CAAA,IAAA,EAAyC,CACrC,KAAA,MAAA,CAAA,KAAA,CAAA,IAAA,CAAA,SAAA,EACA,MAAO,MAAP,MAAA,CACH,CA/KL,CAAA,CAAA,CAAA,GAAA,CAAA,SAAA,CAAA,KAAA,CAyLI,QAAA,CAAA,OAAA,EAAgE,CAAA,IAAA,GAAA,CAAA,KAAA,CAAA,SAAA,CAAA,MAAA,CAA9CH,IAA8C,CAAA,GAAA,CAAA,KAAA,CAAA,KAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,KAAA,CAAA,KAAA,EAAA,CAAA,CAA9CA,IAA8C,CAAA,KAAA,CAA9CA,CAA8C,SAAA,CAAA,KAAA,CAA9CA,CAA8C,CAC5D,GAAMY,CAAAA,WAAW,CAAGC,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAApB,OAAoBA,EAApB,CACA,IAAA,GAAA,CAAA,SAAA,CAAA,+BAAA,CAAA,WAAA,CAAA,CAAA,KAAA,CAAA,CAAA,CAAA,KAAA,CAAA,SAAA,EAAA,EAAA,IAAA,EAAgC,CAAA,GAArBnB,CAAAA,MAAqB,CAAA,KAAA,CAAA,KAAA,CAC5B,GAAMS,CAAAA,IAAI,CAAG,GAAA,CAAA,oBAAA,CAAA,MAAA,CAAA,IAAA,CAAqC,KAArC,IAAA,CAAb,IAAa,CAAb,CACA,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAA,IAAA,CACH,CACD,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAA,IAAA,CAAA,IAAA,CACH,CACD,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,EAAA,CAAA,CACH,CACD,MAAA,KAAA,CACH,CAvML,CAAA,CAAA,CAAA,GAAA,CAAA,UAAA,CAAA,KAAA,CAmNI,QAAA,CAAA,QAAA,CAAA,KAAA,CAAA,IAAA,CAA2E,CACvE,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,MAAO,MAAA,MAAA,CAAP,IAAO,CAAP,CACH,CACD,GAAIC,KAAK,EAAT,CAAA,CAAgB,CACZ,MAAO,MAAA,OAAA,CAAP,IAAO,CAAP,CACH,CAED,GAAII,CAAAA,WAAW,CAAG,KAAlB,IAAA,CACA,GAAIC,CAAAA,YAAY,CAAhB,CAAA,CACA,MAAOA,YAAY,CAAGL,KAAK,CAApBK,CAAAA,EAA4BD,WAAW,CAAXA,IAAAA,GAAnC,IAAA,CAA8D,CAC1DC,YAAY,EAAZA,CAAAA,CACAD,WAAW,CAAGA,WAAW,CAAzBA,IAAAA,CACH,CACDA,WAAW,CAAXA,WAAAA,CAAAA,IAAAA,EACA,MAAA,KAAA,CACH,CAnOL,CAAA,CAAA,CAAA,GAAA,CAAA,YAAA,CAAA,KAAA,CA8OI,QAAA,CAAA,UAAA,CAAA,IAAA,CAAwF,CACpF,GAAIL,IAAI,CAAJA,IAAAA,GAAJ,IAAA,CAAwB,CACpB,KAAM,IAAA,CAAA,cAAA,CAAN,mCAAM,CAAN,CACH,CAED,GAAIA,IAAI,CAAJA,IAAAA,GAAJ,IAAA,CAAwB,CACpBA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CAAiBA,IAAI,CAArBA,IAAAA,CACH,CAED,GAAIA,IAAI,CAAJA,IAAAA,GAAJ,IAAA,CAAwB,CACpBA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CAAiBA,IAAI,CAArBA,IAAAA,CACH,CAED,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAYA,IAAI,CAAhB,IAAA,CACH,CAED,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAYA,IAAI,CAAhB,IAAA,CACH,CAED,KAAA,IAAA,EAAA,CAAA,CACAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CACAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CACAA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CACA,MAAA,CAAA,IAAA,CACH,CAxQL,CAAA,CAAA,CAAA,GAAA,CAAA,UAAA,CAAA,KAAA,CAiRI,QAAA,CAAA,QAAA,CAAA,KAAA,CAA2E,CACvE,GAAMA,CAAAA,IAAI,CAAG,KAAA,OAAA,CAAb,KAAa,CAAb,CACA,MAAOA,CAAAA,IAAI,GAAJA,SAAAA,CAAqB,KAAA,UAAA,CAArBA,IAAqB,CAArBA,CAAP,SAAA,CACH,CApRL,CAAA,CAAA,CAAA,GAAA,CAAA,cAAA,CAAA,KAAA,CA+RI,QAAA,CAAA,YAAA,CAAA,aAAA,CAAA,IAAA,CAG8B,CAC1B,GAAMA,CAAAA,IAAI,CAAG,GAAA,CAAA,oBAAA,CAAA,IAAA,CAA+BW,aAAa,CAA5C,IAAA,CAAA,aAAA,CAAb,IAAa,CAAb,CACA,GAAIA,aAAa,CAAbA,IAAAA,GAAJ,IAAA,CAAiC,CAC7B,KAAA,IAAA,CAAA,IAAA,CACH,CACD,GAAIA,aAAa,CAAbA,IAAAA,GAAJ,IAAA,CAAiC,CAC7BA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA,CAAAA,IAAAA,CACH,CACDA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA,CACA,KAAA,IAAA,EAAA,CAAA,CACA,MAAA,KAAA,CACH,CA7SL,CAAA,CAAA,CAAA,GAAA,CAAA,MAAA,CAAA,KAAA,CAsTI,QAAA,CAAA,IAAA,CAAA,OAAA,CAAwF,CACpF,GAAI,KAAA,IAAA,GAAA,IAAA,EAAsB,KAAA,IAAA,GAA1B,IAAA,CAA8C,CAC1C,MAAA,KAAA,CACH,CACD,GAAI,KAAA,MAAA,CAAJ,CAAA,CAAqB,CACjB,MAAA,KAAA,CACH,CAED,GAAMC,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,CAAA,KAAA,CAAA,GAAA,CAGb,CACD,GAAIC,KAAK,GAAT,GAAA,CAAmB,CACf,OACH,CACD,GAAMC,CAAAA,SAAS,CAAGC,GAAG,CAArB,IAAA,CACA,GAAIC,CAAAA,OAAoC,CAAxC,KAAA,CACA,GAAIC,CAAAA,KAA2B,CAA/B,KAAA,CACA,MAAOD,OAAO,EAAIA,OAAO,GAAzB,GAAA,CAAmC,CAC/B,GAAME,CAAAA,IAAI,CAAGC,OAAO,CAACH,OAAO,CAAR,IAAA,CAApB,SAAoB,CAApB,CACA,GAAA,IAAA,CAAU,CACN,GAAIA,OAAO,GAAX,KAAA,CAAuB,CACnB,GAAMI,CAAAA,IAAI,CAAGH,KAAK,CAAlB,IAAA,CACAA,KAAK,CAALA,IAAAA,CAAaD,OAAO,CAApBC,IAAAA,CACAD,OAAO,CAAPA,IAAAA,CAAAA,IAAAA,CACH,CACDC,KAAK,CAAGA,KAAK,CAAbA,IAAAA,CACH,CACDD,OAAO,CAAGA,OAAO,CAAjBA,IAAAA,CACH,CACDD,GAAG,CAAHA,IAAAA,CAAWE,KAAK,CAAhBF,IAAAA,CACAE,KAAK,CAALA,IAAAA,CAAAA,SAAAA,CAEA,GAAIJ,KAAK,CAALA,IAAAA,GAAeE,GAAG,CAAtB,IAAA,CAA6B,CACzB,OACH,CAED,GAAIE,KAAK,CAALA,IAAAA,EAAcA,KAAK,GAAvB,KAAA,CAAmC,CAC/BL,SAAS,CAAA,KAAA,CAAQK,KAAK,CAAtBL,IAAS,CAATA,CACH,CACD,GAAIK,KAAK,CAALA,IAAAA,EAAcA,KAAK,GAAvB,GAAA,CAAiC,CAC7BL,SAAS,CAACK,KAAK,CAAN,IAAA,CAATL,GAAS,CAATA,CACH,CAlCL,CAAA,CAqCAA,SAAS,CAAC,KAAD,IAAA,CAAY,KAArBA,IAAS,CAATA,CACA,MAAA,KAAA,CACH,CArWL,CAAA,CAAA,CAAA,GAAA,CAAA,aAAA,CAAA,KAAA,CAgXI,QAAA,CAAA,WAAA,CAAA,aAAA,CAAA,IAAA,CAG8B,CAC1B,GAAMZ,CAAAA,IAAI,CAAG,GAAA,CAAA,oBAAA,CAAA,IAAA,CAAA,aAAA,CAA8CW,aAAa,CAA3D,IAAA,CAAb,IAAa,CAAb,CACA,GAAIA,aAAa,CAAbA,IAAAA,GAAJ,IAAA,CAAiC,CAC7B,KAAA,IAAA,CAAA,IAAA,CACH,CACD,GAAIA,aAAa,CAAbA,IAAAA,GAAJ,IAAA,CAAiC,CAC7BA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA,CAAAA,IAAAA,CACH,CACDA,aAAa,CAAbA,IAAAA,CAAAA,IAAAA,CACA,KAAA,IAAA,EAAA,CAAA,CACA,MAAA,KAAA,CACH,CA9XL,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,KAAA,CAuYI,QAAA,CAAA,KAAA,EAAqC,CACjC,MAAO,MAAA,gBAAA,CAAsB,KAA7B,IAAO,CAAP,CACH,CAzYL,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,KAAA,CAkZI,QAAA,CAAA,GAAA,EAAmC,CAC/B,MAAO,MAAA,gBAAA,CAAsB,KAA7B,IAAO,CAAP,CACH,CApZL,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,KAAA,CAiaI,QAAA,CAAA,KAAA,CAAA,IAAA,CAAqD,CACjD,GAAI,KAAA,IAAA,GAAJ,IAAA,CAAwB,CACpB,KAAA,IAAA,CAAA,IAAA,CAAiBjB,IAAI,CAArB,IAAA,CACH,CACD,GAAIA,IAAI,CAAJA,IAAAA,GAAJ,IAAA,CAAwB,CACpBA,IAAI,CAAJA,IAAAA,CAAAA,IAAAA,CAAiB,KAAjBA,IAAAA,CACH,CACD,KAAA,IAAA,CAAY,KAAA,IAAA,EAAaA,IAAI,CAA7B,IAAA,CACA,KAAA,IAAA,CAAYA,IAAI,CAAJA,IAAAA,EAAa,KAAzB,IAAA,CACA,KAAA,IAAA,EAAaA,IAAI,CAAjB,IAAA,CACAA,IAAI,CAAJA,IAAAA,CAAY,KAAZA,IAAAA,CACAA,IAAI,CAAJA,IAAAA,CAAY,KAAZA,IAAAA,CACAA,IAAI,CAAJA,IAAAA,CAAY,KAAZA,IAAAA,CACH,CA9aL,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,KAAA,CAubI,QAAA,CAAA,KAAA,EAAe,CACX,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,CAAA,IAAA,CACA,KAAA,IAAA,CAAA,CAAA,CACA,MAAA,KAAA,CACH,CA5bL,CAAA,CAAA,CAAA,GAAA,CAAA,OAAA,CAAA,KAAA,CA0cI,QAAA,CAAA,KAAA,CAAA,KAAA,CAAA,GAAA,CAA2E,CACvE,GAAMA,CAAAA,IAAI,CAAG,GAAb,CAAA,gBAAa,EAAb,CACA,GAAI2B,CAAAA,MAAM,CAAV,GAAA,CAEA,GAAI,KAAA,IAAA,GAAA,IAAA,EAAsB,KAAA,IAAA,GAA1B,IAAA,CAA8C,CAC1C,MAAA,CAAA,IAAA,CACH,CACD,GAAIA,MAAM,GAANA,SAAAA,EAAwBA,MAAM,CAAlC,KAAA,CAA4C,CACxCA,MAAM,CAAG,KAATA,MAAAA,CACH,CAED,GAAIC,CAAAA,IAAuD,CAAG,KAAA,OAAA,CAA9D,KAA8D,CAA9D,CACA,IAAK,GAAIxB,CAAAA,CAAC,CAAV,CAAA,CAAgBA,CAAC,CAAGuB,MAAM,CAAVvB,KAAAA,EAAsBwB,IAAI,GAA1BxB,IAAAA,EAAuCwB,IAAI,GAA3D,SAAA,CAA2ExB,CAA3E,EAAA,CAAgF,CAC5EJ,IAAI,CAAJA,MAAAA,CAAY4B,IAAI,CAAhB5B,IAAAA,EACA4B,IAAI,CAAGA,IAAI,CAAXA,IAAAA,CACH,CACD,MAAA,CAAA,IAAA,CACH,CA3dL,CAAA,CAAA,CAAA,GAAA,CAAA,SAAA,CAAA,KAAA,CAoeI,QAAA,CAAA,OAAA,EAA6C,CACzC,GAAIjB,CAAAA,WAAW,CAAG,KAAlB,IAAA,CACA,MAAA,WAAA,CAAoB,CAChB,GAAMZ,CAAAA,KAAI,CAAGY,WAAW,CAAxB,IAAA,CACAA,WAAW,CAAXA,IAAAA,CAAmBA,WAAW,CAA9BA,IAAAA,CACAA,WAAW,CAAXA,IAAAA,CAAAA,KAAAA,CACAA,WAAW,CAAGA,WAAW,CAAzBA,IAAAA,CACH,CACD,GAAMkB,CAAAA,IAAI,CAAG,KAAb,IAAA,CACA,KAAA,IAAA,CAAY,KAAZ,IAAA,CACA,KAAA,IAAA,CAAA,IAAA,CACA,MAAA,KAAA,CACH,CAhfL,CAAA,CAAA,CAAA,GAAA,CAAA,SAAA,CAAA,KAAA,CA0fI,QAAA,CAAA,OAAA,CAAA,CAAA,CAAiE,CAAA,GAAvBC,CAAAA,OAAuB,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAb,KAAa,CAC7D,GAAIlB,CAAAA,YAAY,CAAGkB,OAAO,CAAG,KAAA,MAAA,CAAH,CAAA,CAA1B,CAAA,CACA,GAAInB,CAAAA,WAAW,CAAGmB,OAAO,CAAG,KAAH,IAAA,CAAe,KAAxC,IAAA,CACA,GAAMC,CAAAA,QAAQ,CAAGD,OAAO,CAAG,CAAH,CAAA,CAAxB,CAAA,CACA,GAAMpB,CAAAA,QAAQ,CAAGoB,OAAO,CAAA,MAAA,CAAxB,MAAA,CACA,MAAA,WAAA,CAAoB,CAChBjB,CAAC,CAACF,WAAW,CAAZ,IAAA,CAAA,YAAA,CAADE,IAAC,CAADA,CACAF,WAAW,CAAGA,WAAW,CAAzBA,QAAyB,CAAzBA,CACAC,YAAY,EAAZA,QAAAA,CACH,CACJ,CApgBL,CAAA,CAAA,CAAA,GAAA,CAAA,KAAA,CAAA,KAAA,CA+gBI,QAAA,CAAA,GAAA,CAAA,CAAA,CAAwF,CAAA,GAAA,CAAA,MAAA,CAAA,IAAA,CAAA,GAAlDkB,CAAAA,OAAkD,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAxC,KAAwC,CACpF,GAAM9B,CAAAA,IAAI,CAAG,GAAb,CAAA,gBAAa,EAAb,CACA,KAAA,OAAA,CAAa,SAAA,IAAA,CAAA,KAAA,CAAA,CAAA,MAAiBA,CAAAA,IAAI,CAAJA,MAAAA,CAAYa,CAAC,CAAA,IAAA,CAAA,KAAA,CAA9B,MAA8B,CAAbb,CAAjB,CAAb,CAAA,CAAA,OAAA,EACA,MAAA,CAAA,IAAA,CACH,CAnhBL,CAAA,CAAA,CAAA,GAAA,CAAA,QAAA,CAAA,KAAA,CA8hBI,QAAA,CAAA,MAAA,CAAA,CAAA,CAA4F,CAAA,GAAA,CAAA,MAAA,CAAA,IAAA,CAAA,GAAlD8B,CAAAA,OAAkD,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAxC,KAAwC,CACxF,GAAM9B,CAAAA,IAAI,CAAG,GAAb,CAAA,gBAAa,EAAb,CACA,KAAA,OAAA,CAAa,SAAA,IAAA,CAAA,KAAA,CAAiB,CAC1B,GAAIa,CAAC,CAAA,IAAA,CAAA,KAAA,CAAL,MAAK,CAAL,CAA0B,CACtBb,IAAI,CAAJA,MAAAA,CAAAA,IAAAA,EACH,CAHL,CAAA,CAAA,OAAA,EAKA,MAAA,CAAA,IAAA,CACH,CAtiBL,CAAA,CAAA,CAAA,GAAA,CAAA,QAAA,CAAA,KAAA,CAijBI,QAAA,CAAA,MAAA,CAAA,CAAA,CAAA,KAAA,CASO,CAAA,GADH8B,CAAAA,OACG,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CADO,KACP,CACH,GAAIlB,CAAAA,YAAY,CAAGkB,OAAO,CAAG,KAAA,MAAA,CAAH,CAAA,CAA1B,CAAA,CACA,GAAMC,CAAAA,QAAQ,CAAGD,OAAO,CAAG,CAAH,CAAA,CAAxB,CAAA,CACA,GAAMpB,CAAAA,QAAQ,CAAGoB,OAAO,CAAA,MAAA,CAAxB,MAAA,CACA,GAAIE,CAAAA,cAAc,CAAGF,OAAO,CAAG,KAAH,IAAA,CAAe,KAA3C,IAAA,CACA,GAAA,CAAA,MAAA,CAEA,GAAIX,KAAK,GAAT,SAAA,CAAyB,CACrBc,MAAM,CAANA,KAAAA,CADJ,CAAA,IAEO,IAAA,cAAA,CAAoB,CACvBA,MAAM,CAAGD,cAAc,CAAvBC,IAAAA,CACAD,cAAc,CAAGA,cAAc,CAA/BA,QAA+B,CAA/BA,CAFG,CAAA,IAGA,CACH,KAAM,IAAA,CAAA,SAAA,CAAN,kDAAM,CAAN,CACH,CAED,MAAA,cAAA,CAAuB,CACnBC,MAAM,CAAGpB,CAAC,CAAA,MAAA,CAASmB,cAAc,CAAvB,IAAA,CAAA,YAAA,CAAVC,IAAU,CAAVA,CACArB,YAAY,EAAZA,QAAAA,CACAoB,cAAc,CAAGA,cAAc,CAA/BA,QAA+B,CAA/BA,CACH,CAED,MAAA,CAAA,MAAA,CACH,CAjlBL,CAAA,CAAA,CAAA,GAAA,CAAA,SAAA,CAAA,KAAA,CAylBI,QAAA,CAAA,OAAA,EAA6B,CACzB,MAAA,CAAA,kBAAA,CAAA,IAAA,CAAA,CACH,CA3lBL,CAAA,CAAA,CAAA,GAAA,CAAA,UAAA,CAAA,KAAA,CAomBI,QAAA,CAAA,QAAA,EAAyC,CAAA,GAAzBE,CAAAA,SAAyB,CAAA,SAAA,CAAA,MAAA,CAAA,CAAA,EAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA,CAAA,SAAA,CAAA,CAAA,CAAA,CAAb,GAAa,CACrC,MAAO,MAAA,MAAA,CAAY,SAAA,CAAA,CAAA,IAAA,CAAA,CAAA,MAAA,GAAA,CAAA,CAAA,SAAA,CAAA,IAAA,CAAnB,CAAO,CAAP,CACH,CAtmBL,CAAA,CAAA,CAAA,GAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,mBAAA,CAAA,IAAA,CA+mBI,QAAA,CAAA,KAAA,EAAA,CAAA,GAAA,CAAA,OAAA,CAAA,MAAA,CAAA,mBAAA,CAAA,IAAA,CAAA,QAAA,CAAA,MAAA,CAAA,QAAA,CAAA,CAAA,MAAA,CAAA,CAAA,CAAA,OAAA,QAAA,CAAA,IAAA,CAAA,QAAA,CAAA,IAAA,EAAA,IAAA,EAAA,CACQE,OADR,CACkB,KADlB,IACQA,CADR,IAAA,EAAA,CAAA,GAAA,EAGWA,OAAO,GAHlB,IAAA,CAAA,CAAA,CAAA,QAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,CAAA,QAAA,CAAA,IAAA,CAAA,CAAA,CAIQ,MAAMA,CAAAA,OAAO,CAAb,IAAA,CAJR,IAAA,EAAA,CAKQA,OAAO,CAAGA,OAAO,CAAjBA,IAAAA,CALR,QAAA,CAAA,IAAA,CAAA,CAAA,CAAA,MAAA,IAAA,EAAA,CAAA,IAAA,KAAA,CAAA,MAAA,CAAA,QAAA,CAAA,IAAA,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,KAAA,CAAA,IAAA,CAAA,CA/mBJ,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,kBAAA,CAAA,KAAA,CAynBI,QAAA,CAAA,gBAAA,CAAA,IAAA,CAAsE,CAClE,MAAO9B,CAAAA,IAAI,GAAJA,IAAAA,CAAgB,KAAA,UAAA,CAAA,IAAA,EAAhBA,IAAAA,CAAP,SAAA,CACH,CA3nBL,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAA,MAAA,CAAA,KAAA,CAiBI,QAAA,CAAA,IAAA,CAAA,QAAA,CAAkE,CAC9D,MAAA,CAAA,UAAA,CAAA,gBAAA,CAAA,kBAAA,CAAA,QAAA,CAAA,CAAA,CACH,CAnBL,CAAA,CAAA,CAAA,CAAA,MAAA,CAAA,gBAAA,CAAA,CAAA,CA+mBa6B,MAAM,CA/mBnB,QAAA,CAAA","sourcesContent":["/** Type used for filter and find methods, returning a boolean */\r\ntype TTestFunction<NodeData> = (\r\n    data: NodeData,\r\n    index: number,\r\n    list: SinglyLinkedList<NodeData>,\r\n) => boolean;\r\n\r\n/** Type used for map and forEach methods, returning anything */\r\ntype TMapFunction<NodeData> = (\r\n    data: any,\r\n    index: number,\r\n    list: SinglyLinkedList<NodeData>,\r\n) => any;\r\n\r\n/**\r\n * The class which represents one link or node in a linked list\r\n * ```ts\r\n * const node = new SinglyLinkedListNode(1, null, null, null);\r\n * ```\r\n */\r\nexport class SinglyLinkedListNode<NodeData = any> {\r\n    constructor(\r\n        /** Data stored on the node */\r\n        public data: NodeData,\r\n        /** The previous node in the list */\r\n        public prev: SinglyLinkedListNode<NodeData> | null,\r\n        /** The next link in the list */\r\n        public next: SinglyLinkedListNode<NodeData> | null,\r\n        /** The list this node belongs to */\r\n        public list: SinglyLinkedList<NodeData> | null,\r\n    ) {\r\n    }\r\n\r\n    /**\r\n     * Alias to .data\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).head.value; // 1\r\n     * ```\r\n     */\r\n    public get value() {\r\n        return this.data;\r\n    }\r\n\r\n    /**\r\n     * Get the index of this node\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).head.index; // 0\r\n     * ```\r\n     */\r\n    public get index() {\r\n        if (!this.list) {\r\n            return undefined;\r\n        }\r\n        return this.list.findIndex((value) => value === this.value);\r\n    }\r\n\r\n    /**\r\n     * Insert a new node before this one\r\n     * ```ts\r\n     * new LinkedList(2, 3).head.insertBefore(1); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param data Data to save in the node\r\n     */\r\n    public insertBefore(data: NodeData): SinglyLinkedList<NodeData> {\r\n        return this.list !== null\r\n            ? this.list.insertBefore(this, data)\r\n            : new SinglyLinkedList(data, this.data);\r\n    }\r\n\r\n    /**\r\n     * Insert new data after this node\r\n     * ```ts\r\n     * new LinkedList(1, 2).tail.insertAfter(3); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param data Data to be saved in the node\r\n     */\r\n    public insertAfter(data: NodeData): SinglyLinkedList<NodeData> {\r\n        return this.list !== null\r\n            ? this.list.insertAfter(this, data)\r\n            : new SinglyLinkedList(this.data, data);\r\n    }\r\n\r\n    /**\r\n     * Remove this node\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3, 4).tail.remove(); // 1 <=> 2 <=> 3\r\n     * ```\r\n     */\r\n    public remove(): SinglyLinkedListNode<NodeData> {\r\n        if (this.list === null) {\r\n            throw new ReferenceError('Node does not belong to any list');\r\n        }\r\n        return this.list.removeNode(this);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * A doubly linked list\r\n * ```ts\r\n * const list = new LinkedList(1, 2, 3);\r\n * const listFromArray = LinkedList.from([1, 2, 3]);\r\n * ```\r\n */\r\nexport class SinglyLinkedList<NodeData = any> {\r\n\r\n    /**\r\n     * The length of the list\r\n     */\r\n    public get length(): number {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Convert any iterable to a new linked list\r\n     * ```javascript\r\n     * const array = [1, 2, 3];\r\n     * const list = LinkedList.from(array);\r\n     * ```\r\n     * @param iterable Any iterable datatype like Array or Map\r\n     */\r\n    public static from<T>(iterable: Iterable<T>): SinglyLinkedList<T> {\r\n        return new SinglyLinkedList(...iterable);\r\n    }\r\n\r\n    /** The head of the list, the first node */\r\n    public head: SinglyLinkedListNode<NodeData> | null;\r\n\r\n    /** The tail of the list, the last node */\r\n    public tail: SinglyLinkedListNode<NodeData> | null;\r\n\r\n    /** Internal size reference */\r\n    private size: number;\r\n\r\n    constructor(...args: NodeData[]) {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n\r\n        for (let i = 0; i < arguments.length; i++) {\r\n            this.append(arguments[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the node data at a specified index, zero based\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).get(0); // 1\r\n     * ```\r\n     * @param index to retrieve data at\r\n     */\r\n    public get(index: number): NodeData | undefined {\r\n        const node = this.getNode(index);\r\n        return node !== undefined ? node.data : undefined;\r\n    }\r\n\r\n    /**\r\n     * Get the node at index, zero based\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).getNode(0);\r\n     * // { prev: null, data: 1, next: SinglyLinkedListNode }\r\n     * ```\r\n     */\r\n    public getNode(index: number): SinglyLinkedListNode<NodeData> | undefined {\r\n        if (this.head === null || index < 0 || index >= this.length) {\r\n            return undefined;\r\n        }\r\n        const asc = index < this.length / 2;\r\n        const stopAt = asc ? index : this.length - index - 1;\r\n        const nextNode = asc ? 'next' : 'prev';\r\n        let currentNode = asc ? this.head : this.tail;\r\n        for (let currentIndex = 0; currentIndex < stopAt; currentIndex++) {\r\n            currentNode = currentNode![nextNode];\r\n        }\r\n        return currentNode!;\r\n    }\r\n\r\n    /**\r\n     * Return the first node and its index in the list that\r\n     * satisfies the testing function\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).findNodeIndex(data => data === 1);\r\n     * // { node: SinglyLinkedListNode, index: 0 }\r\n     * ```\r\n     * @param f A function to be applied to the data of each node\r\n     */\r\n    public findNodeIndex(f: TTestFunction<NodeData>): ({\r\n        node: SinglyLinkedListNode<NodeData>,\r\n        index: number,\r\n    }) | undefined {\r\n        let currentIndex = 0;\r\n        let currentNode = this.head;\r\n        while (currentNode) {\r\n            if (f(currentNode.data, currentIndex, this)) {\r\n                return {\r\n                    index: currentIndex,\r\n                    node: currentNode,\r\n                };\r\n            }\r\n            currentNode = currentNode.next;\r\n            currentIndex += 1;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the first node in the list that\r\n     * satisfies the provided testing function. Otherwise undefined is returned.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).findNode(data => data === 1);\r\n     * // { prev: null, data: 1, next: SinglyLinkedListNode }\r\n     * ```\r\n     * @param f Function to test data against\r\n     */\r\n    public findNode(f: TTestFunction<NodeData>): SinglyLinkedListNode<NodeData> | undefined {\r\n        const nodeIndex = this.findNodeIndex(f);\r\n        return nodeIndex !== undefined ? nodeIndex.node : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the value of the first element in the list that\r\n     * satisfies the provided testing function. Otherwise undefined is returned.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).find(data => data === 1); // 1\r\n     * ```\r\n     * @param f Function to test data against\r\n     */\r\n    public find(f: TTestFunction<NodeData>): NodeData | undefined {\r\n        const nodeIndex = this.findNodeIndex(f);\r\n        return nodeIndex !== undefined ? nodeIndex.node.data : undefined;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the first node in the list that\r\n     * satisfies the provided testing function. Ohterwise -1 is returned.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).findIndex(data => data === 3); // 2\r\n     * ```\r\n     * @param f Function to test data against\r\n     */\r\n    public findIndex(f: TTestFunction<NodeData>): number {\r\n        const nodeIndex = this.findNodeIndex(f);\r\n        return nodeIndex !== undefined ? nodeIndex.index : -1;\r\n    }\r\n\r\n    /**\r\n     * Append one or any number of nodes to the end of the list.\r\n     * This modifies the list in place and returns the list itself\r\n     * to make this method chainable.\r\n     * ```ts\r\n     * new LinkedList(1).append(2).append(3, 4); // 1 <=> 2 <=> 3 <=> 4\r\n     * ```\r\n     * @param args Data to be stored in the node, takes any number of arguments\r\n     */\r\n    public append(...args: NodeData[]): SinglyLinkedList<NodeData> {\r\n        for (const data of args) {\r\n            const node = new SinglyLinkedListNode(data, this.tail, null, this);\r\n            if (this.head === null) {\r\n                this.head = node;\r\n            }\r\n            if (this.tail !== null) {\r\n                this.tail.next = node;\r\n            }\r\n            this.tail = node;\r\n            this.size += 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synonym for append\r\n     * ```ts\r\n     * new LinkedList(1).push(2).push(3, 4); // 1 <=> 2 <=> 3 <=> 4\r\n     * ```\r\n     * @param args Data to be stored, takes any number of arguments\r\n     */\r\n    public push(...args: NodeData[]): number {\r\n        this.append(...args);\r\n        return this.length;\r\n    }\r\n\r\n    /**\r\n     * Prepend any number of data arguments to the list. The\r\n     * argument list is prepended as a block to reduce confusion:\r\n     * ```javascript\r\n     * new LinkedList(3, 4).prepend(0, 1, 2); // [0, 1, 2, 3, 4]\r\n     * ```\r\n     * @param args Data to be stored in the node, accepts any number of arguments\r\n     */\r\n    public prepend(...args: NodeData[]): SinglyLinkedList<NodeData> {\r\n        const reverseArgs = Array.from(args).reverse();\r\n        for (const data of reverseArgs) {\r\n            const node = new SinglyLinkedListNode(data, null, this.head, this);\r\n            if (this.tail === null) {\r\n                this.tail = node;\r\n            }\r\n            if (this.head !== null) {\r\n                this.head.prev = node;\r\n            }\r\n            this.head = node;\r\n            this.size += 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert a new node at a given index position. If index is\r\n     * out of bounds, the node is appended, if index is negative\r\n     * or 0, it will be prepended.\r\n     * ```ts\r\n     * new LinkedList(1, 3).insertAt(1, 2); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param index The index to insert the new node at\r\n     * @param data Data to be stored on the new node\r\n     */\r\n    public insertAt(index: number, data: NodeData): SinglyLinkedList<NodeData> {\r\n        if (this.head === null) {\r\n            return this.append(data);\r\n        }\r\n        if (index <= 0) {\r\n            return this.prepend(data);\r\n        }\r\n\r\n        let currentNode = this.head;\r\n        let currentIndex = 0;\r\n        while (currentIndex < index - 1 && currentNode.next !== null) {\r\n            currentIndex += 1;\r\n            currentNode = currentNode.next;\r\n        }\r\n        currentNode.insertAfter(data);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the specified node from the list and return the removed\r\n     * node afterwards.\r\n     * ```ts\r\n     * const list = new LinkedList(1, 2, 3);\r\n     * list.removeNode(list.tail); // { prev: null, data: 3, next: null, list: null }\r\n     * ```\r\n     * @param node The node to be removed\r\n     */\r\n    public removeNode(node: SinglyLinkedListNode<NodeData>): SinglyLinkedListNode<NodeData> {\r\n        if (node.list !== this) {\r\n            throw new ReferenceError('Node does not belong to this list');\r\n        }\r\n\r\n        if (node.prev !== null) {\r\n            node.prev.next = node.next;\r\n        }\r\n\r\n        if (node.next !== null) {\r\n            node.next.prev = node.prev;\r\n        }\r\n\r\n        if (this.head === node) {\r\n            this.head = node.next;\r\n        }\r\n\r\n        if (this.tail === node) {\r\n            this.tail = node.prev;\r\n        }\r\n\r\n        this.size -= 1;\r\n        node.next = null;\r\n        node.prev = null;\r\n        node.list = null;\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Remove the node at the specified index\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).removeAt(2); // { prev: null, data: 3, next: null, list: null }\r\n     * ```\r\n     * @param index Index at which to remove\r\n     */\r\n    public removeAt(index: number): SinglyLinkedListNode<NodeData> | undefined {\r\n        const node = this.getNode(index);\r\n        return node !== undefined ? this.removeNode(node) : undefined;\r\n    }\r\n\r\n    /**\r\n     * Insert a new node before the reference node\r\n     * ```ts\r\n     * const list = new LinkedList(1, 3);\r\n     * list.insertBefore(list.tail, 2); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param referenceNode The node reference\r\n     * @param data Data to save in the node\r\n     */\r\n    public insertBefore(\r\n        referenceNode: SinglyLinkedListNode<NodeData>,\r\n        data: NodeData,\r\n    ): SinglyLinkedList<NodeData> {\r\n        const node = new SinglyLinkedListNode(data, referenceNode.prev, referenceNode, this);\r\n        if (referenceNode.prev === null) {\r\n            this.head = node;\r\n        }\r\n        if (referenceNode.prev !== null) {\r\n            referenceNode.prev.next = node;\r\n        }\r\n        referenceNode.prev = node;\r\n        this.size += 1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sorts the linked list using the provided compare function\r\n     * @param compare A function used to compare the data of two nodes. It should return\r\n     *                a boolean. True will insert a before b, false will insert b before a.\r\n     *                (a, b) => a < b or (1, 2) => 1 < 2 === true, 2 will be inserted after 1,\r\n     *                the sort order will be ascending.\r\n     */\r\n    public sort(compare: (a: NodeData, b: NodeData) => boolean): SinglyLinkedList<NodeData> {\r\n        if (this.head === null || this.tail === null) {\r\n            return this;\r\n        }\r\n        if (this.length < 2) {\r\n            return this;\r\n        }\r\n\r\n        const quicksort = (\r\n            start: SinglyLinkedListNode<NodeData>,\r\n            end: SinglyLinkedListNode<NodeData>,\r\n        ) => {\r\n            if (start === end) {\r\n                return;\r\n            }\r\n            const pivotData = end.data;\r\n            let current: SinglyLinkedListNode | null = start;\r\n            let split: SinglyLinkedListNode = start;\r\n            while (current && current !== end) {\r\n                const sort = compare(current.data, pivotData);\r\n                if (sort) {\r\n                    if (current !== split) {\r\n                        const temp = split.data;\r\n                        split.data = current.data;\r\n                        current.data = temp;\r\n                    }\r\n                    split = split.next!;\r\n                }\r\n                current = current.next;\r\n            }\r\n            end.data = split.data;\r\n            split.data = pivotData;\r\n\r\n            if (start.next === end.prev) {\r\n                return;\r\n            }\r\n\r\n            if (split.prev && split !== start) {\r\n                quicksort(start, split.prev);\r\n            }\r\n            if (split.next && split !== end) {\r\n                quicksort(split.next, end);\r\n            }\r\n        };\r\n\r\n        quicksort(this.head, this.tail);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Insert a new node after this one\r\n     * ```ts\r\n     * const list = new LinkedList(2, 3);\r\n     * list.insertAfter(list.head, 1); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param referenceNode The reference node\r\n     * @param data Data to be saved in the node\r\n     */\r\n    public insertAfter(\r\n        referenceNode: SinglyLinkedListNode<NodeData>,\r\n        data: NodeData,\r\n    ): SinglyLinkedList<NodeData> {\r\n        const node = new SinglyLinkedListNode(data, referenceNode, referenceNode.next, this);\r\n        if (referenceNode.next === null) {\r\n            this.tail = node;\r\n        }\r\n        if (referenceNode.next !== null) {\r\n            referenceNode.next.prev = node;\r\n        }\r\n        referenceNode.next = node;\r\n        this.size += 1;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove the first node from the list and return the data of the removed node\r\n     * or undefined\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).shift(); // 1\r\n     * ```\r\n     */\r\n    public shift(): NodeData | undefined {\r\n        return this.removeFromAnyEnd(this.head);\r\n    }\r\n\r\n    /**\r\n     * Remove the last node from the list and return the data of the removed node\r\n     * or undefined if the list was empty\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).pop(); // 3\r\n     * ```\r\n     */\r\n    public pop(): NodeData | undefined {\r\n        return this.removeFromAnyEnd(this.tail);\r\n    }\r\n\r\n    /**\r\n     * Merge the current list with another. Both lists will be\r\n     * equal after merging.\r\n     * ```ts\r\n     * const list = new LinkedList(1, 2);\r\n     * const otherList = new LinkedList(3);\r\n     * list.merge(otherList);\r\n     * (list === otherList); // true\r\n     * ```\r\n     * @param list The list to be merged\r\n     */\r\n    public merge(list: SinglyLinkedList<NodeData>): void {\r\n        if (this.tail !== null) {\r\n            this.tail.next = list.head;\r\n        }\r\n        if (list.head !== null) {\r\n            list.head.prev = this.tail;\r\n        }\r\n        this.head = this.head || list.head;\r\n        this.tail = list.tail || this.tail;\r\n        this.size += list.size;\r\n        list.size = this.size;\r\n        list.head = this.head;\r\n        list.tail = this.tail;\r\n    }\r\n\r\n    /**\r\n     * Removes all nodes from a list\r\n     *\r\n     * ```ts\r\n     * list.clear();\r\n     * ```\r\n     */\r\n    public clear() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The slice() method returns a shallow copy of a\r\n     * portion of a list into a new list object selected\r\n     * from start to end (end not included).\r\n     * The original list will not be modified.\r\n     * ```ts\r\n     * const list = new LinkedList(1, 2, 3, 4, 5);\r\n     * const newList = list.slice(0, 3); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param start Start index\r\n     * @param end End index, optional\r\n     */\r\n    public slice(start: number, end?: number): SinglyLinkedList<NodeData | {}> {\r\n        const list = new SinglyLinkedList();\r\n        let finish = end;\r\n\r\n        if (this.head === null || this.tail === null) {\r\n            return list;\r\n        }\r\n        if (finish === undefined || finish < start) {\r\n            finish = this.length;\r\n        }\r\n\r\n        let head: SinglyLinkedListNode<NodeData> | null | undefined = this.getNode(start);\r\n        for (let i = 0; i < finish - start && head !== null && head !== undefined; i++) {\r\n            list.append(head.data);\r\n            head = head.next;\r\n        }\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * The reverse() function reverses the list in place and returns the list\r\n     * itself.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).reverse(); // 3 <=> 2 <=> 1\r\n     * ```\r\n     */\r\n    public reverse(): SinglyLinkedList<NodeData> {\r\n        let currentNode = this.head;\r\n        while (currentNode) {\r\n            const next = currentNode.next;\r\n            currentNode.next = currentNode.prev;\r\n            currentNode.prev = next;\r\n            currentNode = currentNode.prev;\r\n        }\r\n        const tail = this.tail;\r\n        this.tail = this.head;\r\n        this.head = tail;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The forEach() method executes a provided function once for each list node.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).forEach(data => log(data)); // 1 2 3\r\n     * ```\r\n     * @param f Function to execute for each element, taking up to three arguments.\r\n     * @param reverse Indicates if the list should be walked in reverse order, default is false\r\n     */\r\n    public forEach(f: TMapFunction<NodeData>, reverse = false): void {\r\n        let currentIndex = reverse ? this.length - 1 : 0;\r\n        let currentNode = reverse ? this.tail : this.head;\r\n        const modifier = reverse ? -1 : 1;\r\n        const nextNode = reverse ? 'prev' : 'next';\r\n        while (currentNode) {\r\n            f(currentNode.data, currentIndex, this);\r\n            currentNode = currentNode[nextNode];\r\n            currentIndex += modifier;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The map() method creates a new list with the results of\r\n     * calling a provided function on every node in the calling list.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).map(data => data + 10); // 11 <=> 12 <=> 13\r\n     * ```\r\n     * @param f Function that produces an node of the new list, taking up to three arguments\r\n     * @param reverse Indicates if the list should be mapped in reverse order, default is false\r\n     */\r\n    public map(f: TMapFunction<NodeData>, reverse = false): SinglyLinkedList<NodeData | {}> {\r\n        const list = new SinglyLinkedList();\r\n        this.forEach((data, index) => list.append(f(data, index, this)), reverse);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * The filter() method creates a new list with all nodes\r\n     * that pass the test implemented by the provided function.\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3, 4, 5).filter(data => data < 4); // 1 <=> 2 <=> 3\r\n     * ```\r\n     * @param f Function to test each node data in the list. Return true to keep the node\r\n     * @param reverse Indicates if the list should be filtered in reverse order, default is false\r\n     */\r\n    public filter(f: TTestFunction<NodeData>, reverse = false): SinglyLinkedList<NodeData | {}> {\r\n        const list = new SinglyLinkedList();\r\n        this.forEach((data, index) => {\r\n            if (f(data, index, this)) {\r\n                list.append(data);\r\n            }\r\n        }, reverse);\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     * Reduce over each node in the list\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).reduce(n => n += 1, 0); // 3\r\n     * ```\r\n     * @param f A reducer function\r\n     * @param start An initial value\r\n     * @returns The final state of the accumulator\r\n     */\r\n    public reduce(\r\n        f: (\r\n            accumulator: any,\r\n            currentNode: NodeData,\r\n            index: number,\r\n            list: SinglyLinkedList<NodeData>,\r\n        ) => any,\r\n        start?: any,\r\n        reverse = false,\r\n    ): any {\r\n        let currentIndex = reverse ? this.length - 1 : 0;\r\n        const modifier = reverse ? -1 : 1;\r\n        const nextNode = reverse ? 'prev' : 'next';\r\n        let currentElement = reverse ? this.tail : this.head;\r\n        let result;\r\n\r\n        if (start !== undefined) {\r\n            result = start;\r\n        } else if (currentElement) {\r\n            result = currentElement.data;\r\n            currentElement = currentElement[nextNode];\r\n        } else {\r\n            throw new TypeError('Reduce of empty LinkedList with no initial value');\r\n        }\r\n\r\n        while (currentElement) {\r\n            result = f(result, currentElement.data, currentIndex, this);\r\n            currentIndex += modifier;\r\n            currentElement = currentElement[nextNode];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert the linked list to an array\r\n     * ```ts\r\n     * new LinkedList(1, 2, 3).toArray(); // [1, 2, 3]\r\n     * ```\r\n     */\r\n    public toArray(): NodeData[] {\r\n        return [...this];\r\n    }\r\n\r\n    /**\r\n     * Convert a linked list to string\r\n     * ```ts\r\n     * new LinkedList('one', 'two', 'three').toString(' <=> ') === 'one <=> two <=> three';\r\n     * ```\r\n     * @param separator Optional string to be placed in between data nodes, default is one space\r\n     */\r\n    public toString(separator = ' '): string {\r\n        return this.reduce((s, data) => `${s}${separator}${data}`);\r\n    }\r\n\r\n    /**\r\n     * The iterator implementation\r\n     * ```ts\r\n     * const list = new LinkedList(1, 2, 3);\r\n     * for (const data of list) { log(data); } // 1 2 3\r\n     * ```\r\n     */\r\n    public* [Symbol.iterator](): IterableIterator<NodeData> {\r\n        let element = this.head;\r\n\r\n        while (element !== null) {\r\n            yield element.data;\r\n            element = element.next;\r\n        }\r\n    }\r\n\r\n    /** Private helper function to reduce duplication of pop() and shift() methods */\r\n    private removeFromAnyEnd(node: SinglyLinkedListNode<NodeData> | null) {\r\n        return node !== null ? this.removeNode(node).data : undefined;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}