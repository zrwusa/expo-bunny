{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";export var HeapNode=function(){function HeapNode(id,val){_classCallCheck(this,HeapNode);if(val===undefined){val=null;}this._id=id;this._val=val||null;}_createClass(HeapNode,[{key:\"id\",get:function get(){return this._id;},set:function set(v){this._id=v;}},{key:\"val\",get:function get(){return this._val;},set:function set(v){this._val=v;}}]);return HeapNode;}();export var Heap=function(){function Heap(nodes){_classCallCheck(this,Heap);this._nodes=Array.isArray(nodes)?_toConsumableArray(nodes):[];this._fix();}_createClass(Heap,[{key:\"_swap\",value:function _swap(i,j){var temp=this._nodes[i];this._nodes[i]=this._nodes[j];this._nodes[j]=temp;}},{key:\"_shouldSwap\",value:function _shouldSwap(parentIndex,childIndex){if(parentIndex<0||parentIndex>=this.size()-1)return false;if(childIndex<1||childIndex>this.size()-1)return false;return!this.compare(parentIndex,childIndex);}},{key:\"_parentIndex\",value:function _parentIndex(childIndex){var parentIndex=Math.floor((childIndex-1)/2);if(parentIndex<0||parentIndex>=this.size()-1)return-1;return parentIndex;}},{key:\"_hasParent\",value:function _hasParent(childIndex){return this._parentIndex(childIndex)>-1;}},{key:\"_leftChildIndex\",value:function _leftChildIndex(parentIndex){var leftChildIndex=parentIndex*2+1;if(leftChildIndex<1||leftChildIndex>this.size()-1){return-1;}else{return leftChildIndex;}}},{key:\"_rightChildIndex\",value:function _rightChildIndex(parentIndex){var rightChildIndex=parentIndex*2+2;if(rightChildIndex<1||rightChildIndex>this.size()-1){return-1;}else{return rightChildIndex;}}},{key:\"_hasLeftChild\",value:function _hasLeftChild(parentIndex){return this._leftChildIndex(parentIndex)!==-1;}},{key:\"_hasRightChild\",value:function _hasRightChild(parentIndex){return this._rightChildIndex(parentIndex)!==-1;}},{key:\"_compareChildren\",value:function _compareChildren(parentIndex){if(!this._hasLeftChild(parentIndex)&&!this._hasRightChild(parentIndex))return-1;var leftChildIndex=this._leftChildIndex(parentIndex),rightChildIndex=this._rightChildIndex(parentIndex);if(!this._hasLeftChild(parentIndex))return rightChildIndex;if(!this._hasRightChild(parentIndex))return leftChildIndex;return this.compare(leftChildIndex,rightChildIndex)?leftChildIndex:rightChildIndex;}},{key:\"_fix\",value:function _fix(){for(var i=Math.floor(this.size()/2);i>-1;i--){this.heapifyDown(i);}}},{key:\"heapifyUp\",value:function heapifyUp(startingIndex){var childIndex=startingIndex;var parentIndex=Math.floor((childIndex-1)/2);while(this._shouldSwap(parentIndex,childIndex)){this._swap(parentIndex,childIndex);childIndex=parentIndex;parentIndex=Math.floor((childIndex-1)/2);}return childIndex;}},{key:\"heapifyDown\",value:function heapifyDown(startingIndex){var parentIndex=startingIndex;var childIndex=this._compareChildren(parentIndex);while(this._shouldSwap(parentIndex,childIndex)){this._swap(parentIndex,childIndex);parentIndex=childIndex;childIndex=this._compareChildren(parentIndex);}return parentIndex;}},{key:\"poll\",value:function poll(){var res;if(this.size()>1){this._swap(0,this._nodes.length-1);res=this._nodes.pop();this.heapifyDown(0);}else{if(this.size()===1){res=this._nodes.pop();}else{res=null;}}return res;}},{key:\"insert\",value:function insert(node,priority){if(priority!==undefined){if(node instanceof HeapNode){node.id=priority;}}this._nodes.push(node);this.heapifyUp(this._nodes.length-1);}},{key:\"isValidNode\",value:function isValidNode(index){return this._nodes[index]!==undefined;}},{key:\"isValid\",value:function isValid(){var _this=this;var isValidRecursive=function isValidRecursive(parentIndex){var isValidLeft=true;var isValidRight=true;if(_this._hasLeftChild(parentIndex)){var leftChildIndex=parentIndex*2+1;if(!_this.compare(parentIndex,leftChildIndex))return false;isValidLeft=isValidRecursive(leftChildIndex);}if(_this._hasRightChild(parentIndex)){var rightChildIndex=parentIndex*2+2;if(!_this.compare(parentIndex,rightChildIndex))return false;isValidRight=isValidRecursive(rightChildIndex);}return isValidLeft&&isValidRight;};return isValidRecursive(0);}},{key:\"toArray\",value:function toArray(){return this._nodes;}},{key:\"peek\",value:function peek(){return this.isValidNode(0)?this._nodes[0]:null;}},{key:\"leaf\",value:function leaf(){return this.isValidNode(this.size()-1)?this._nodes[this.size()-1]:null;}},{key:\"size\",value:function size(){return this._nodes.length;}},{key:\"isEmpty\",value:function isEmpty(){return this.size()===0;}},{key:\"sort\",value:function sort(nodeOrPropertyName){var visitedId=[];var visitedVal=[];var visitedNode=[];var visitedNumber=[];var pushByValueType=function pushByValueType(node){switch(nodeOrPropertyName){case'id':if(node instanceof HeapNode){visitedId.push(node.id);}break;case'val':if(node instanceof HeapNode){visitedVal.push(node.val);}break;case'node':if(node instanceof HeapNode){visitedNode.push(node);}break;default:if(typeof node==='number'){visitedNumber.push(node);}break;}};while(!this.isEmpty()){var top=this.poll();if(top){pushByValueType(top);}}switch(nodeOrPropertyName){case'id':return visitedId;case'val':return visitedVal;case'node':return visitedNode;default:return visitedNumber;}}},{key:\"DFS\",value:function DFS(dfsMode,nodeOrPropertyName){var _this2=this;var visitedId=[];var visitedVal=[];var visitedNode=[];var visitedNumber=[];var pushByValueType=function pushByValueType(index){var node=_this2._nodes[index];switch(nodeOrPropertyName){case'id':if(node instanceof HeapNode){visitedId.push(node.id);}break;case'val':if(node instanceof HeapNode){visitedVal.push(node.val);}break;case'node':if(node instanceof HeapNode){visitedNode.push(node);}break;default:if(typeof node==='number'){visitedNumber.push(node);}break;}};var _traverse=function _traverse(cur){var leftChildIndex=cur*2+1;var rightChildIndex=cur*2+2;switch(dfsMode){case'in':if(_this2.isValidNode(leftChildIndex))_traverse(leftChildIndex);pushByValueType(cur);if(_this2.isValidNode(rightChildIndex))_traverse(rightChildIndex);break;case'pre':pushByValueType(cur);if(_this2.isValidNode(leftChildIndex))_traverse(leftChildIndex);if(_this2.isValidNode(rightChildIndex))_traverse(rightChildIndex);break;case'post':if(_this2.isValidNode(leftChildIndex))_traverse(leftChildIndex);if(_this2.isValidNode(rightChildIndex))_traverse(rightChildIndex);pushByValueType(cur);break;}};this.isValidNode(0)&&_traverse(0);switch(nodeOrPropertyName){case'id':return visitedId;case'val':return visitedVal;case'node':return visitedNode;default:return visitedNumber;}}},{key:\"clear\",value:function clear(){this._nodes=[];}}]);return Heap;}();","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/data-structures/heap/heap.ts"],"names":["HeapNode","val","Heap","Array","temp","parentIndex","childIndex","Math","leftChildIndex","rightChildIndex","i","res","priority","node","isValidRecursive","isValidLeft","isValidRight","visitedId","visitedVal","visitedNode","visitedNumber","pushByValueType","top","_traverse","cur"],"mappings":"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","sourcesContent":["// Online Algorithms use Heap (e.g. Top K problems)\n// Offline Algorithms use sort\nimport {DFSMode} from '../common';\n\nexport type HeapNodePropertyName = 'id' | 'val';\nexport type HeapNodeOrPropertyName = 'node' | HeapNodePropertyName;\n\n\nexport class HeapNode<V> {\n    private _id: number | string;\n    get id(): number | string {\n        return this._id;\n    }\n\n    set id(v: number | string) {\n        this._id = v;\n    }\n\n    private _val: V | null;\n    get val(): V | null {\n        return this._val;\n    }\n\n    set val(v: V | null) {\n        this._val = v;\n    }\n\n    constructor(id: number | string, val?: V | null) {\n        if (val === undefined) {\n            val = null;\n        }\n        this._id = id;\n        this._val = val || null;\n    }\n}\n\nexport abstract class Heap<T extends number | HeapNode<V>, V> {\n    protected _nodes: T[];\n\n    protected constructor(nodes?: T[]) {\n        // TODO support distinct\n        this._nodes = Array.isArray(nodes) ? [...nodes] : [];\n        this._fix();\n    }\n\n    abstract compare(parentIndex: number, childIndex: number): boolean;\n\n    abstract clone(): Heap<T, V>;\n\n    protected _swap(i: number, j: number) {\n        const temp = this._nodes[i];\n        this._nodes[i] = this._nodes[j];\n        this._nodes[j] = temp;\n        // ES6 swap\n        // [this._nodes[i], this._nodes[j]] = [this._nodes[j], this._nodes[i]];\n    }\n\n    protected _shouldSwap(parentIndex: number, childIndex: number) {\n        if (parentIndex < 0 || parentIndex >= (this.size() - 1)) return false;\n        if (childIndex < 1 || childIndex > (this.size() - 1)) return false;\n        return !this.compare(parentIndex, childIndex);\n    }\n\n    protected _parentIndex(childIndex: number): number {\n        const parentIndex = Math.floor((childIndex - 1) / 2);\n        if (parentIndex < 0 || parentIndex >= (this.size() - 1)) return -1;\n        return parentIndex;\n    }\n\n    protected _hasParent(childIndex: number): boolean {\n        return this._parentIndex(childIndex) > -1;\n    }\n\n    protected _leftChildIndex(parentIndex: number): number {\n        const leftChildIndex = parentIndex * 2 + 1;\n        if (leftChildIndex < 1 || leftChildIndex > (this.size() - 1)) {\n            return -1;\n        } else {\n            return leftChildIndex;\n        }\n    }\n\n    protected _rightChildIndex(parentIndex: number): number {\n        const rightChildIndex = parentIndex * 2 + 2;\n        if (rightChildIndex < 1 || rightChildIndex > (this.size() - 1)) {\n            return -1;\n        } else {\n            return rightChildIndex;\n        }\n    }\n\n    protected _hasLeftChild(parentIndex: number) {\n        return this._leftChildIndex(parentIndex) !== -1;\n    }\n\n    protected _hasRightChild(parentIndex: number) {\n        return this._rightChildIndex(parentIndex) !== -1;\n    }\n\n    protected _compareChildren(parentIndex: number): number {\n        if (!this._hasLeftChild(parentIndex) && !this._hasRightChild(parentIndex)) return -1;\n        const leftChildIndex = this._leftChildIndex(parentIndex), rightChildIndex = this._rightChildIndex(parentIndex);\n        if (!this._hasLeftChild(parentIndex)) return rightChildIndex;\n        if (!this._hasRightChild(parentIndex)) return leftChildIndex;\n        return this.compare(leftChildIndex, rightChildIndex) ? leftChildIndex : rightChildIndex;\n    }\n\n    protected _fix() {\n        for (let i = Math.floor(this.size() / 2); i > -1; i--) {\n            this.heapifyDown(i);\n        }\n    }\n\n    heapifyUp(startingIndex: number): number {\n        let childIndex = startingIndex;\n        let parentIndex = Math.floor((childIndex - 1) / 2);\n        while (this._shouldSwap(parentIndex, childIndex)) {\n            this._swap(parentIndex, childIndex);\n            childIndex = parentIndex;\n            parentIndex = Math.floor((childIndex - 1) / 2);\n        }\n        return childIndex;\n    }\n\n    heapifyDown(startingIndex: number): number {\n        let parentIndex = startingIndex;\n        let childIndex = this._compareChildren(parentIndex);\n        while (this._shouldSwap(parentIndex, childIndex)) {\n            this._swap(parentIndex, childIndex);\n            parentIndex = childIndex;\n            childIndex = this._compareChildren(parentIndex);\n        }\n        return parentIndex;\n    }\n\n    poll(): T | null {\n        let res;\n        if (this.size() > 1) {\n            this._swap(0, this._nodes.length - 1);\n            res = this._nodes.pop()!;\n            this.heapifyDown(0);\n        } else {\n            if (this.size() === 1) {\n                res = this._nodes.pop()!;\n            } else {\n                res = null;\n            }\n        }\n\n        return res;\n    }\n\n    insert(node: T, priority?: number | string): void {\n        // TODO may bugs exist for priorities\n        if (priority !== undefined) {\n            if (node instanceof HeapNode) {\n                node.id = priority;\n            }\n        }\n        this._nodes.push(node);\n        this.heapifyUp(this._nodes.length - 1);\n    }\n\n    isValidNode(index: number): boolean {\n        return this._nodes[index] !== undefined;\n    }\n\n    isValid(): boolean {\n        const isValidRecursive = (parentIndex: number): boolean => {\n            let isValidLeft = true;\n            let isValidRight = true;\n\n            if (this._hasLeftChild(parentIndex)) {\n                const leftChildIndex = (parentIndex * 2) + 1;\n                if (!this.compare(parentIndex, leftChildIndex)) return false;\n                isValidLeft = isValidRecursive(leftChildIndex);\n            }\n\n            if (this._hasRightChild(parentIndex)) {\n                const rightChildIndex = (parentIndex * 2) + 2;\n                if (!this.compare(parentIndex, rightChildIndex)) return false;\n                isValidRight = isValidRecursive(rightChildIndex);\n            }\n\n            return isValidLeft && isValidRight;\n        };\n\n        return isValidRecursive(0);\n    }\n\n    toArray(): T[] {\n        return this._nodes;\n    }\n\n    peek(): T | null {\n        return this.isValidNode(0) ? this._nodes[0] : null;\n    }\n\n    leaf(): T | null {\n        return this.isValidNode(this.size() - 1) ? this._nodes[this.size() - 1] : null;\n    }\n\n    size(): number {\n        return this._nodes.length;\n    }\n\n    isEmpty() {\n        return this.size() === 0;\n    }\n\n    // --- start additional functions\n    sort(): number[];\n    sort(nodeOrPropertyName: 'id'): number[];\n    sort(nodeOrPropertyName: 'val'): (V | null)[];\n    sort(nodeOrPropertyName: 'node'): HeapNode<V>[];\n    sort(nodeOrPropertyName?: HeapNodeOrPropertyName) {\n        const visitedId: (number | string)[] = [];\n        const visitedVal: (V | null)[] = [];\n        const visitedNode: HeapNode<V>[] = [];\n        const visitedNumber: number[] = [];\n\n\n        const pushByValueType = (node: number | HeapNode<V>) => {\n            switch (nodeOrPropertyName) {\n                case 'id':\n                    if (node instanceof HeapNode) {\n                        visitedId.push(node.id);\n                    }\n                    break;\n                case 'val':\n                    if (node instanceof HeapNode) {\n                        visitedVal.push(node.val);\n                    }\n                    break;\n                case 'node':\n                    if (node instanceof HeapNode) {\n                        visitedNode.push(node);\n                    }\n                    break;\n                default:\n                    if (typeof node === 'number') {\n                        visitedNumber.push(node);\n                    }\n                    break;\n            }\n        };\n\n        // while (!this.isEmpty()) {\n        //     this._swap(0, this.size() - 1);\n        //     pushByValueType(this.size() - 1);\n        //     this._nodes.pop();\n        //     this.heapifyDown(0);\n        // }\n\n        while (!this.isEmpty()) {\n            const top = this.poll();\n            if (top) {\n                pushByValueType(top);\n            }\n        }\n\n\n        switch (nodeOrPropertyName) {\n            case 'id':\n                return visitedId;\n            case 'val':\n                return visitedVal;\n            case 'node':\n                return visitedNode;\n            default:\n                return visitedNumber;\n        }\n    }\n\n    DFS(dfsMode: DFSMode): number[];\n    DFS(dfsMode: DFSMode, nodeOrPropertyName: 'id'): number[];\n    DFS(dfsMode: DFSMode, nodeOrPropertyName: 'val'): (V | null)[];\n    DFS(dfsMode: DFSMode, nodeOrPropertyName: 'node'): HeapNode<V>[];\n    DFS(dfsMode: DFSMode, nodeOrPropertyName?: HeapNodeOrPropertyName) {\n        const visitedId: (number | string)[] = [];\n        const visitedVal: (V | null)[] = [];\n        const visitedNode: HeapNode<V>[] = [];\n        const visitedNumber: number[] = [];\n\n        const pushByValueType = (index: number) => {\n            const node: number | HeapNode<V> = this._nodes[index];\n            switch (nodeOrPropertyName) {\n                case 'id':\n                    if (node instanceof HeapNode) {\n                        visitedId.push(node.id);\n                    }\n                    break;\n                case 'val':\n                    if (node instanceof HeapNode) {\n                        visitedVal.push(node.val);\n                    }\n                    break;\n                case 'node':\n                    if (node instanceof HeapNode) {\n                        visitedNode.push(node);\n                    }\n                    break;\n                default:\n                    if (typeof node === 'number') {\n                        visitedNumber.push(node);\n                    }\n                    break;\n            }\n        };\n\n        const _traverse = (cur: number) => {\n            const leftChildIndex = cur * 2 + 1;\n            const rightChildIndex = cur * 2 + 2;\n            switch (dfsMode) {\n                case 'in':\n                    if (this.isValidNode(leftChildIndex)) _traverse(leftChildIndex);\n                    pushByValueType(cur);\n                    if (this.isValidNode(rightChildIndex)) _traverse(rightChildIndex);\n                    break;\n                case 'pre':\n                    pushByValueType(cur);\n                    if (this.isValidNode(leftChildIndex)) _traverse(leftChildIndex);\n                    if (this.isValidNode(rightChildIndex)) _traverse(rightChildIndex);\n                    break;\n                case 'post':\n                    if (this.isValidNode(leftChildIndex)) _traverse(leftChildIndex);\n                    if (this.isValidNode(rightChildIndex)) _traverse(rightChildIndex);\n                    pushByValueType(cur);\n                    break;\n            }\n\n        };\n\n        this.isValidNode(0) && _traverse(0);\n        switch (nodeOrPropertyName) {\n            case 'id':\n                return visitedId;\n            case 'val':\n                return visitedVal;\n            case 'node':\n                return visitedNode;\n            default:\n                return visitedNumber;\n        }\n    }\n\n    clear() {\n        this._nodes = [];\n    }\n\n    // --- end additional functions\n}\n"]},"metadata":{},"sourceType":"module"}