{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{BinaryTree,BinaryTreeNode}from\"./binary-tree\";export var BSTNode=function(_BinaryTreeNode){_inherits(BSTNode,_BinaryTreeNode);var _super=_createSuper(BSTNode);function BSTNode(){_classCallCheck(this,BSTNode);return _super.apply(this,arguments);}_createClass(BSTNode,[{key:\"clone\",value:function clone(){return new BSTNode(this._id,this._val,this._count);}}]);return BSTNode;}(BinaryTreeNode);export var BST=function(_BinaryTree){_inherits(BST,_BinaryTree);var _super2=_createSuper(BST);function BST(autoPrefixSum,id,val,count){var _this;_classCallCheck(this,BST);_this=_super2.call(this,id,val,count);_this._autoAllLesserSum=false;if(autoPrefixSum){_this._autoAllLesserSum=true;}return _this;}_createClass(BST,[{key:\"createNode\",value:function createNode(id,val,count){return new BSTNode(id,val,count);}},{key:\"insert\",value:function insert(id,val,count){var inserted=[];var newNode=this.createNode(id,val,count);var newId=newNode.id;if(this.root===null){this.root=newNode;this._size++;inserted.push(this.root);}else{var cur=this.root;var traversing=true;while(traversing){if(cur.id===newId){this._autoAllLesserSum&&cur.right&&this.subTreeAdd(cur.right,newNode.count,'allLesserSum');cur.count+=newNode.count;traversing=false;inserted.push(cur);}else if(newId<cur.id){this._autoAllLesserSum&&cur.right&&this.subTreeAdd(cur.right,newNode.count,'allLesserSum');if(this._autoAllLesserSum)cur.allLesserSum+=newNode.count;if(cur.left===null){if(this._autoAllLesserSum)newNode.allLesserSum=cur.allLesserSum-newNode.count;newNode.parent=cur;newNode.familyPosition=1;cur.left=newNode;this._size++;traversing=false;inserted.push(cur.left);}else{cur=cur.left;}}else if(newId>cur.id){if(cur.right===null){if(this._autoAllLesserSum)newNode.allLesserSum=cur.allLesserSum+cur.count;newNode.parent=cur;newNode.familyPosition=2;cur.right=newNode;this._size++;traversing=false;inserted.push(cur.right);}else{cur=cur.right;}}}}return inserted;}},{key:\"remove\",value:function remove(id,isUpdateAllLeftSum){if(isUpdateAllLeftSum===undefined){isUpdateAllLeftSum=true;}var bstDeletedResult=[];if(this.root===null)return bstDeletedResult;var current=this.getNode(id);if(current===null)return bstDeletedResult;var parent=current!=null&&current.parent?current.parent:null;var needBalanced=null;var orgCurrent=current;var deletedCount=current.count;if(current.left===null){if(parent===null){this.root=current.right;}else{switch(current.familyPosition){case 1:parent.left=current.right;break;case 2:parent.right=current.right;break;}needBalanced=parent;}}else{var leftSubTreeMax=this.getMaxNode(current.left);var parentOfLeftSubTreeMax=leftSubTreeMax.parent;orgCurrent=current.swapLocation(leftSubTreeMax);if(parentOfLeftSubTreeMax){if(parentOfLeftSubTreeMax.right===leftSubTreeMax){parentOfLeftSubTreeMax.right=leftSubTreeMax.left;}else{parentOfLeftSubTreeMax.left=leftSubTreeMax.left;}needBalanced=parentOfLeftSubTreeMax;}}this._size--;this._autoAllLesserSum&&isUpdateAllLeftSum&&this.allGreaterNodesAdd(current,-deletedCount,'allLesserSum');bstDeletedResult.push({deleted:orgCurrent,needBalanced:needBalanced});return bstDeletedResult;}},{key:\"isBST\",value:function isBST(){if(!this.root)return true;function dfs(cur,min,max){if(!cur)return true;if(cur.id<=min||cur.id>=max)return false;return dfs(cur.left,min,cur.id)&&dfs(cur.right,cur.id,max);}return dfs(this.root,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);}},{key:\"contains\",value:function contains(node){return false;}},{key:\"getNodes\",value:function getNodes(nodeProperty,propertyName,onlyOne){if(propertyName===undefined){propertyName='id';}var result=[];function _traverse(cur){switch(propertyName){case'id':if(cur.id===nodeProperty){result.push(cur);if(onlyOne)return;}break;case'count':if(cur.count===nodeProperty){result.push(cur);if(onlyOne)return;}break;case'val':if(cur.val===nodeProperty){result.push(cur);if(onlyOne)return;}break;case'allLesserSum':if(cur.allLesserSum===nodeProperty){result.push(cur);if(onlyOne)return;}break;default:if(cur.id===nodeProperty){result.push(cur);if(onlyOne)return;}break;}if(!cur.left&&!cur.right)return null;if(propertyName==='id'){if(nodeProperty<cur.id){cur.left?_traverse(cur.left):null;}if(nodeProperty>cur.id){cur.right?_traverse(cur.right):null;}}else{cur.left?_traverse(cur.left):null;cur.right?_traverse(cur.right):null;}}this.root&&_traverse(this.root);return result;}},{key:\"getNode\",value:function getNode(nodeProperty,propertyName){if(propertyName===undefined){propertyName='id';}var node=this.getNodes(nodeProperty,propertyName,true)[0];if(node){return node;}else{return null;}}},{key:\"getMinNode\",value:function getMinNode(node){if(!node){node=this.root;}function _traverse(cur){if(!cur.left)return cur;return _traverse(cur.left);}return node?_traverse(node):null;}},{key:\"getMaxNode\",value:function getMaxNode(node){if(!node){node=this.root;}function _traverse(cur){if(!cur.right)return cur;return _traverse(cur.right);}return node?_traverse(node):null;}},{key:\"lesserSum\",value:function lesserSum(id,propertyName){var _this2=this;if(propertyName===undefined){propertyName='id';}var sum=0;var _traverse=function _traverse(cur){var needSum;switch(propertyName){case'id':needSum=cur.id;break;case'count':needSum=cur.count;break;case'allLesserSum':needSum=cur.allLesserSum;break;default:needSum=cur.id;break;}var curId=cur.id;if(id===curId){if(cur.right){sum+=_this2.subTreeSum(cur.right,propertyName);}return;}if(id>curId){if(cur.left){sum+=_this2.subTreeSum(cur.left,propertyName);}sum+=needSum;if(cur.right){_traverse(cur.right);}else{return;}}if(id<curId){if(cur.left){_traverse(cur.left);}else{return;}}};this.root&&_traverse(this.root);return sum;}},{key:\"subTreeAdd\",value:function subTreeAdd(subTreeRoot,delta,propertyName){var _this3=this;if(propertyName===undefined){propertyName='id';}var _traverse=function _traverse(cur){switch(propertyName){case'id':cur.id+=delta;break;case'count':cur.count+=delta;_this3._autoAllLesserSum&&_this3.allGreaterNodesAdd(cur,delta,'allLesserSum');break;case'allLesserSum':cur.allLesserSum+=delta;break;default:cur.id+=delta;break;}if(!cur.left&&!cur.right)return;cur.left&&_traverse(cur.left);cur.right&&_traverse(cur.right);};if(subTreeRoot){_traverse(subTreeRoot);return true;}return false;}},{key:\"allGreaterNodesAdd\",value:function allGreaterNodesAdd(node,delta,propertyName){var _this4=this;if(propertyName===undefined){propertyName='id';}var _traverse=function _traverse(cur){if(cur.id>node.id){switch(propertyName){case'id':cur.id+=delta;break;case'count':cur.count+=delta;_this4._autoAllLesserSum&&_this4.allGreaterNodesAdd(cur,delta,'allLesserSum');break;case'allLesserSum':cur.allLesserSum+=delta;break;default:cur.id+=delta;break;}}if(!cur.left&&!cur.right)return;cur.left&&cur.id>node.id&&_traverse(cur.left);cur.right&&_traverse(cur.right);};if(this.root){_traverse(this.root);return true;}return false;}},{key:\"balance\",value:function balance(){var _this5=this;var sorted=this.DFS('in','node');this.clear();var buildBalanceBST=function buildBalanceBST(l,r){if(l>r)return;var m=Math.floor(l+(r-l)/2);var midNode=sorted[Math.floor(l+(r-l)/2)];_this5.insert(midNode.id,midNode.val,midNode.count);buildBalanceBST(l,m-1);buildBalanceBST(m+1,r);};if(sorted.length>0){buildBalanceBST(0,sorted.length-1);return true;}else{return false;}}},{key:\"isAVLBalanced\",value:function isAVLBalanced(){var balanced=true;var _height=function _height(cur){if(!cur)return 0;var leftHeight=_height(cur.left);var rightHeight=_height(cur.right);if(Math.abs(leftHeight-rightHeight)>1){balanced=false;return Infinity;}return Math.max(leftHeight,rightHeight)+1;};_height(this.root);return balanced;}}]);return BST;}(BinaryTree);","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/utils/data-structures/binary-tree/bst.ts"],"names":["BSTNode","BST","_autoAllLesserSum","inserted","newNode","newId","cur","traversing","isUpdateAllLeftSum","bstDeletedResult","current","parent","needBalanced","orgCurrent","deletedCount","leftSubTreeMax","parentOfLeftSubTreeMax","deleted","dfs","Number","propertyName","result","nodeProperty","_traverse","node","sum","needSum","curId","id","sorted","buildBalanceBST","l","m","Math","r","midNode","balanced","_height","leftHeight","rightHeight"],"mappings":"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","sourcesContent":["import {BinaryTree, BinaryTreeNode, BinaryTreeNodeId, BinaryTreeNodePropertyName, I_BinaryTree} from './binary-tree';\n\nexport type BSTDeletedResult<T> = { deleted: BSTNode<T> | null, needBalanced: BSTNode<T> | null };\n\nexport class BSTNode<T> extends BinaryTreeNode<T> {\n    clone(): BSTNode<T> {\n        return new BSTNode<T>(this._id, this._val, this._count);\n    }\n}\n\nexport interface I_BST<T> extends I_BinaryTree<T> {\n    // --- start basic functions\n    isBST(): boolean;\n\n    insert(id: BinaryTreeNodeId, val?: T | null, count?: number): (BSTNode<T> | null)[];\n\n    contains(node: BSTNode<T>): boolean;\n\n    remove(id: BinaryTreeNodeId, isUpdateAllLeftSum?: boolean): BSTDeletedResult<T>[];\n\n    getNodes(nodeProperty: BinaryTreeNodeId | number | T, propertyName ?: BinaryTreeNodePropertyName, onlyOne ?: boolean): BSTNode<T>[];\n\n    getNode(nodeProperty: BinaryTreeNodeId | number | T, propertyName ?: BinaryTreeNodePropertyName): BSTNode<T> | null;\n\n    // --- end basic functions\n\n    // --- start additional functions\n    getMinNode(node?: BSTNode<T> | null): BSTNode<T> | null;\n\n    getMaxNode(node?: BSTNode<T> | null): BSTNode<T> | null;\n\n    lesserSum(id: BinaryTreeNodeId, propertyName ?: BinaryTreeNodePropertyName): number;\n\n    subTreeAdd(subTreeRoot: BSTNode<T>, delta: number, propertyName ?: BinaryTreeNodePropertyName): boolean;\n\n    allGreaterNodesAdd(node: BSTNode<T>, delta: number, propertyName ?: BinaryTreeNodePropertyName): boolean;\n\n    balance(): boolean;\n\n    isAVLBalanced(): boolean;\n\n    // --- end additional functions\n}\n\nexport class BST<T> extends BinaryTree<T> implements I_BST<T> {\n\n    protected readonly _autoAllLesserSum: boolean = false;\n\n    constructor(autoPrefixSum?: boolean, id?: BinaryTreeNodeId, val?: T | null, count?: number) {\n        super(id, val, count);\n        if (autoPrefixSum) {\n            this._autoAllLesserSum = true;\n        }\n    }\n\n    // --- start basic functions\n    createNode(id: BinaryTreeNodeId, val?: T | null, count?: number): BSTNode<T> {\n        return new BSTNode<T>(id, val, count);\n    }\n\n    insert(id: BinaryTreeNodeId, val?: T | null, count?: number): (BSTNode<T> | null)[] {\n        const inserted: BSTNode<T>[] = [];\n        const newNode = this.createNode(id, val, count);\n        const newId = newNode.id;\n        if (this.root === null) {\n            this.root = newNode;\n            this._size++;\n            inserted.push(this.root);\n        } else {\n            let cur = this.root;\n            let traversing = true;\n            while (traversing) {\n                if (cur.id === newId) {\n                    this._autoAllLesserSum && cur.right && this.subTreeAdd(cur.right, newNode.count, 'allLesserSum');\n                    cur.count += newNode.count;\n                    //Duplicates are not accepted.\n                    traversing = false;\n                    inserted.push(cur);\n                } else if (newId < cur.id) {\n                    this._autoAllLesserSum && cur.right && this.subTreeAdd(cur.right, newNode.count, 'allLesserSum');\n                    if (this._autoAllLesserSum) cur.allLesserSum += newNode.count;\n                    // Traverse left of the node\n                    if (cur.left === null) {\n                        if (this._autoAllLesserSum) newNode.allLesserSum = cur.allLesserSum - newNode.count;\n                        newNode.parent = cur;\n                        newNode.familyPosition = 1;\n                        //Add to the left of the current node\n                        cur.left = newNode;\n                        this._size++;\n                        traversing = false;\n                        inserted.push(cur.left);\n                    } else {\n                        //Traverse the left of the current node\n                        cur = cur.left;\n                    }\n                } else if (newId > cur.id) {\n                    // Traverse right of the node\n                    if (cur.right === null) {\n                        if (this._autoAllLesserSum) newNode.allLesserSum = cur.allLesserSum + cur.count;\n                        newNode.parent = cur;\n                        newNode.familyPosition = 2;\n                        //Add to the right of the current node\n                        cur.right = newNode;\n                        this._size++;\n                        traversing = false;\n                        inserted.push(cur.right);\n                    } else {\n                        //Traverse the left of the current node\n                        cur = cur.right;\n                    }\n                }\n            }\n        }\n        return inserted;\n    }\n\n    remove(id: BinaryTreeNodeId, isUpdateAllLeftSum?: boolean): BSTDeletedResult<T>[] {\n\n        if (isUpdateAllLeftSum === undefined) {\n            isUpdateAllLeftSum = true;\n        }\n\n        let bstDeletedResult: BSTDeletedResult<T>[] = [];\n\n        if (this.root === null) return bstDeletedResult; // Element is not in the tree\n\n        // Locate the node to be deleted and also locate its parent node\n        let current: BSTNode<T> | null = this.getNode(id);\n        if (current === null) return bstDeletedResult; // Element is not in the tree\n\n        const parent: BSTNode<T> | null = current?.parent ? current.parent : null;\n        let needBalanced: BSTNode<T> | null = null;\n        let orgCurrent = current;\n        const deletedCount = current.count;\n\n        // Case 1: current has no left children (See Figure 23.6)\n        if (current.left === null) {\n            // Connect the parent with the right child of the current node\n            if (parent === null) {\n                this.root = current.right;\n            } else {\n                switch (current.familyPosition) {\n                    case 1:\n                        parent.left = current.right;\n                        break;\n                    case 2:\n                        parent.right = current.right;\n                        break;\n                }\n                needBalanced = parent;\n            }\n        } else {\n            // Case 2: The current node has a left child\n            // Locate the rightmost node in the left subtree of\n            // the current node and also its parent\n            let leftSubTreeMax = this.getMaxNode(current.left);\n            let parentOfLeftSubTreeMax = leftSubTreeMax.parent;\n\n            // Replace the element in current by the element in leftSubTreeMax\n            orgCurrent = current.swapLocation(leftSubTreeMax);\n\n            // Eliminate rightmost node\n            if (parentOfLeftSubTreeMax) {\n                if (parentOfLeftSubTreeMax.right === leftSubTreeMax) {\n                    parentOfLeftSubTreeMax.right = leftSubTreeMax.left;\n                } else {\n                    // Special case: parentOfLeftSubTreeMax is current\n                    parentOfLeftSubTreeMax.left = leftSubTreeMax.left;\n                }\n                needBalanced = parentOfLeftSubTreeMax;\n            }\n        }\n\n        this._size--;\n        this._autoAllLesserSum && isUpdateAllLeftSum && this.allGreaterNodesAdd(current, -deletedCount, 'allLesserSum');\n        bstDeletedResult.push({deleted: orgCurrent, needBalanced});\n        return bstDeletedResult;\n    }\n\n    isBST(): boolean {\n        if (!this.root) return true;\n\n        function dfs(cur: BSTNode<T> | null, min: BinaryTreeNodeId, max: BinaryTreeNodeId): boolean {\n            if (!cur) return true;\n            if ((cur.id <= min) || (cur.id >= max)) return false;\n            return dfs(cur.left, min, cur.id) && dfs(cur.right, cur.id, max);\n        }\n\n        return dfs(this.root!, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n\n        // if (!this.root) return true;\n        //\n        // let valid = true;\n        //\n        // function dfs(cur: BSTNode<T> | null, min: BinaryTreeNodeId, max: BinaryTreeNodeId): void {\n        //     if (!cur) return;\n        //     if (cur.id <= min || cur.id >= max) {\n        //         valid = false;\n        //         return;\n        //     }\n        //     dfs(cur.left, min, cur.id);\n        //     dfs(cur.right, cur.id, max);\n        // }\n        //\n        // dfs(this.root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n        // return valid;\n    }\n\n    contains(node: BSTNode<T>): boolean {\n        return false;\n    }\n\n    getNodes(nodeProperty: BinaryTreeNodeId | number | T, propertyName ?: BinaryTreeNodePropertyName, onlyOne ?: boolean): BSTNode<T>[] {\n        if (propertyName === undefined) {\n            propertyName = 'id';\n        }\n\n        const result: BSTNode<T>[] = [];\n\n        function _traverse(cur: BSTNode<T>) {\n            switch (propertyName) {\n                case 'id':\n                    if (cur.id === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne) return;\n                    }\n                    break;\n                case 'count':\n                    if (cur.count === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne) return;\n                    }\n                    break;\n                case 'val':\n                    if (cur.val === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne) return;\n                    }\n                    break;\n                case 'allLesserSum':\n                    if (cur.allLesserSum === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne) return;\n                    }\n                    break;\n                default:\n                    if (cur.id === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne) return;\n                    }\n                    break;\n            }\n\n            if (!cur.left && !cur.right) return null;\n            if (propertyName === 'id') {\n                if (nodeProperty < cur.id) {\n                    cur.left ? _traverse(cur.left) : null;\n                }\n                if (nodeProperty > cur.id) {\n                    cur.right ? _traverse(cur.right) : null;\n                }\n            } else {\n                cur.left ? _traverse(cur.left) : null;\n                cur.right ? _traverse(cur.right) : null;\n            }\n        }\n\n        this.root && _traverse(this.root);\n        return result;\n    }\n\n    getNode(nodeProperty: BinaryTreeNodeId | number | T, propertyName ?: BinaryTreeNodePropertyName): BSTNode<T> | null {\n        if (propertyName === undefined) {\n            propertyName = 'id';\n        }\n        const node = this.getNodes(nodeProperty, propertyName, true)[0];\n        if (node) {\n            return node;\n        } else {\n            return null;\n        }\n    }\n\n    // --- end basic functions\n\n    // --- start additional functions\n    getMinNode(): BSTNode<T> | null;\n    getMinNode(node: BSTNode<T>): BSTNode<T>;\n    getMinNode(node?: BSTNode<T> | null): BSTNode<T> | null {\n        if (!node) {\n            node = this.root;\n        }\n\n        function _traverse(cur: BSTNode<T>): BSTNode<T> {\n            if (!cur.left) return cur;\n            return _traverse(cur.left);\n        }\n\n        return node ? _traverse(node) : null;\n    }\n\n    getMaxNode(): BSTNode<T> | null;\n    getMaxNode(node: BSTNode<T>): BSTNode<T>;\n    getMaxNode(node?: BSTNode<T> | null): BSTNode<T> | null {\n        if (!node) {\n            node = this.root;\n        }\n\n        function _traverse(cur: BSTNode<T>): BSTNode<T> {\n            if (!cur.right) return cur;\n            return _traverse(cur.right);\n        }\n\n        return node ? _traverse(node) : null;\n    }\n\n    // getMaxNode(node?: BSTNode<T> | null): BSTNode<T> | null {\n    //     if (!node) {\n    //         node = this.root;\n    //     }\n    //\n    //     const _findByPath = (cur: BSTNode<T>) => {\n    //         while (cur.right) {\n    //             cur = cur.right; // Keep going to the right\n    //         }\n    //         return cur;\n    //     }\n    //\n    //     return node ? _findByPath(node) : null;\n    // }\n\n    lesserSum(id: BinaryTreeNodeId, propertyName ?: BinaryTreeNodePropertyName): number {\n        if (propertyName === undefined) {\n            propertyName = 'id';\n        }\n        let sum = 0;\n        const _traverse = (cur: BSTNode<T>): void => {\n            let needSum: number;\n            switch (propertyName) {\n                case 'id':\n                    needSum = cur.id;\n                    break;\n                case 'count':\n                    needSum = cur.count;\n                    break;\n                case 'allLesserSum':\n                    needSum = cur.allLesserSum;\n                    break;\n                default:\n                    needSum = cur.id;\n                    break;\n            }\n            const curId = cur.id;\n\n            if (id === curId) {\n                if (cur.right) {\n                    sum += this.subTreeSum(cur.right, propertyName);\n                }\n                return;\n            }\n\n            if (id > curId) {\n                if (cur.left) {\n                    sum += this.subTreeSum(cur.left, propertyName);\n                }\n                sum += needSum;\n                if (cur.right) {\n                    _traverse(cur.right);\n                } else {\n                    return;\n                }\n            }\n\n            if (id < curId) {\n                if (cur.left) {\n                    _traverse(cur.left);\n                } else {\n                    return;\n                }\n            }\n        };\n\n        this.root && _traverse(this.root);\n        return sum;\n    }\n\n    subTreeAdd(subTreeRoot: BSTNode<T>, delta: number, propertyName ?: BinaryTreeNodePropertyName): boolean {\n        if (propertyName === undefined) {\n            propertyName = 'id';\n        }\n\n        const _traverse = (cur: BSTNode<T>) => {\n            switch (propertyName) {\n                case 'id':\n                    cur.id += delta;\n                    break;\n                case 'count':\n                    cur.count += delta;\n                    this._autoAllLesserSum && this.allGreaterNodesAdd(cur, delta, 'allLesserSum');\n                    break;\n                case 'allLesserSum':\n                    cur.allLesserSum += delta;\n                    break;\n                default:\n                    cur.id += delta;\n                    break;\n            }\n            if (!cur.left && !cur.right) return;\n            cur.left && _traverse(cur.left);\n            cur.right && _traverse(cur.right);\n        };\n\n        if (subTreeRoot) {\n            _traverse(subTreeRoot);\n            return true;\n        }\n        return false;\n    }\n\n    allGreaterNodesAdd(node: BSTNode<T>, delta: number, propertyName ?: BinaryTreeNodePropertyName): boolean {\n        if (propertyName === undefined) {\n            propertyName = 'id';\n        }\n\n        const _traverse = (cur: BSTNode<T>) => {\n            if (cur.id > node.id) {\n                switch (propertyName) {\n                    case 'id':\n                        cur.id += delta;\n                        break;\n                    case 'count':\n                        cur.count += delta;\n                        this._autoAllLesserSum && this.allGreaterNodesAdd(cur, delta, 'allLesserSum');\n                        break;\n                    case 'allLesserSum':\n                        cur.allLesserSum += delta;\n                        break;\n                    default:\n                        cur.id += delta;\n                        break;\n                }\n            }\n\n            if (!cur.left && !cur.right) return;\n            (cur.left && cur.id > node.id) && _traverse(cur.left);\n            cur.right && _traverse(cur.right);\n        };\n\n        if (this.root) {\n            _traverse(this.root);\n            return true;\n        }\n        return false;\n    }\n\n    balance(): boolean {\n        const sorted = this.DFS('in', 'node');\n\n        this.clear();\n        const buildBalanceBST = (l: number, r: number) => {\n            if (l > r) return;\n            const m = Math.floor(l + (r - l) / 2);\n            const midNode = sorted[Math.floor(l + (r - l) / 2)];\n            this.insert(midNode.id, midNode.val, midNode.count);\n            buildBalanceBST(l, m - 1);\n            buildBalanceBST(m + 1, r);\n        };\n\n        if (sorted.length > 0) {\n            buildBalanceBST(0, sorted.length - 1);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    isAVLBalanced(): boolean {\n        let balanced = true;\n        const _height = (cur: BSTNode<T> | null): number => {\n            if (!cur) return 0;\n            let leftHeight = _height(cur.left);\n            let rightHeight = _height(cur.right);\n            if (Math.abs(leftHeight - rightHeight) > 1) {\n                balanced = false;\n                return Infinity;\n            }\n            return Math.max(leftHeight, rightHeight) + 1;\n        };\n\n        _height(this.root);\n        return balanced;\n    }\n\n    // --- end additional functions\n}\n"]},"metadata":{},"sourceType":"module"}