{"ast":null,"code":"\"use strict\";var _interopRequireDefault=require(\"@babel/runtime/helpers/interopRequireDefault\");var _defineProperty2=_interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));var _slicedToArray2=_interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _extends2=_interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _createForOfIteratorHelperLoose(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;return function(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}it=o[Symbol.iterator]();return it.next.bind(it);}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}exports.__esModule=true;exports.matchHas=matchHas;exports.compileNonPath=compileNonPath;exports.default=prepareDestination;exports.getSafeParamName=void 0;var _querystring=require(\"./querystring\");var _parseRelativeUrl=require(\"./parse-relative-url\");var pathToRegexp=_interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));function _getRequireWildcardCache(){if(typeof WeakMap!==\"function\")return null;var cache=new WeakMap();_getRequireWildcardCache=function _getRequireWildcardCache(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}var getSafeParamName=function getSafeParamName(paramName){var newParamName='';for(var i=0;i<paramName.length;i++){var charCode=paramName.charCodeAt(i);if(charCode>64&&charCode<91||charCode>96&&charCode<123){newParamName+=paramName[i];}}return newParamName;};exports.getSafeParamName=getSafeParamName;function matchHas(req,has,query){var params={};var allMatch=has.every(function(hasItem){var value;var key=hasItem.key;switch(hasItem.type){case'header':{key=key.toLowerCase();value=req.headers[key];break;}case'cookie':{value=req.cookies[hasItem.key];break;}case'query':{value=query[key];break;}case'host':{var _ref=(req==null?void 0:req.headers)||{},host=_ref.host;var hostname=host==null?void 0:host.split(':')[0].toLowerCase();value=hostname;break;}default:{break;}}if(!hasItem.value&&value){params[getSafeParamName(key)]=value;return true;}else if(value){var matcher=new RegExp(\"^\"+hasItem.value+\"$\");var matches=value.match(matcher);if(matches){if(matches.groups){Object.keys(matches.groups).forEach(function(groupKey){params[groupKey]=matches.groups[groupKey];});}else if(hasItem.type==='host'&&matches[0]){params.host=matches[0];}return true;}}return false;});if(allMatch){return params;}return false;}function compileNonPath(value,params){if(!value.includes(':')){return value;}for(var _i=0,_Object$keys=Object.keys(params);_i<_Object$keys.length;_i++){var key=_Object$keys[_i];if(value.includes(\":\"+key)){value=value.replace(new RegExp(\":\"+key+\"\\\\*\",'g'),\":\"+key+\"--ESCAPED_PARAM_ASTERISKS\").replace(new RegExp(\":\"+key+\"\\\\?\",'g'),\":\"+key+\"--ESCAPED_PARAM_QUESTION\").replace(new RegExp(\":\"+key+\"\\\\+\",'g'),\":\"+key+\"--ESCAPED_PARAM_PLUS\").replace(new RegExp(\":\"+key+\"(?!\\\\w)\",'g'),\"--ESCAPED_PARAM_COLON\"+key);}}value=value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g,'\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g,'+').replace(/--ESCAPED_PARAM_COLON/g,':').replace(/--ESCAPED_PARAM_QUESTION/g,'?').replace(/--ESCAPED_PARAM_ASTERISKS/g,'*');return pathToRegexp.compile(\"/\"+value,{validate:false})(params).substr(1);}function prepareDestination(destination,params,query,appendParamsToQuery){var parsedDestination={};query=(0,_extends2.default)({},query);var hadLocale=query.__nextLocale;delete query.__nextLocale;delete query.__nextDefaultLocale;if(destination.startsWith('/')){parsedDestination=(0,_parseRelativeUrl.parseRelativeUrl)(destination);}else{var _URL=new URL(destination),pathname=_URL.pathname,searchParams=_URL.searchParams,hash=_URL.hash,hostname=_URL.hostname,port=_URL.port,protocol=_URL.protocol,search=_URL.search,href=_URL.href;parsedDestination={pathname:pathname,query:(0,_querystring.searchParamsToUrlQuery)(searchParams),hash:hash,protocol:protocol,hostname:hostname,port:port,search:search,href:href};}var destQuery=parsedDestination.query;var destPath=\"\"+parsedDestination.pathname+(parsedDestination.hash||'');var destPathParamKeys=[];pathToRegexp.pathToRegexp(destPath,destPathParamKeys);var destPathParams=destPathParamKeys.map(function(key){return key.name;});var destinationCompiler=pathToRegexp.compile(destPath,{validate:false});var newUrl;for(var _i2=0,_Object$entries=Object.entries(destQuery);_i2<_Object$entries.length;_i2++){var _ref2=_Object$entries[_i2];var _ref3=(0,_slicedToArray2.default)(_ref2,2);var key=_ref3[0];var strOrArray=_ref3[1];var value=Array.isArray(strOrArray)?strOrArray[0]:strOrArray;if(value){value=compileNonPath(value,params);}destQuery[key]=value;}var paramKeys=Object.keys(params);if(hadLocale){paramKeys=paramKeys.filter(function(name){return name!=='nextInternalLocale';});}if(appendParamsToQuery&&!paramKeys.some(function(key){return destPathParams.includes(key);})){for(var _iterator=_createForOfIteratorHelperLoose(paramKeys),_step;!(_step=_iterator()).done;){var _key=_step.value;if(!(_key in destQuery)){destQuery[_key]=params[_key];}}}try{newUrl=destinationCompiler(params);var _newUrl$split=newUrl.split('#'),_newUrl$split2=(0,_slicedToArray2.default)(_newUrl$split,2),_pathname=_newUrl$split2[0],_hash=_newUrl$split2[1];parsedDestination.pathname=_pathname;parsedDestination.hash=\"\"+(_hash?'#':'')+(_hash||'');delete parsedDestination.search;}catch(err){if(err.message.match(/Expected .*? to not repeat, but got an array/)){throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match\");}throw err;}parsedDestination.query=_objectSpread(_objectSpread({},query),parsedDestination.query);return{newUrl:newUrl,parsedDestination:parsedDestination};}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["getSafeParamName","paramName","newParamName","i","charCode","params","allMatch","has","hasItem","key","value","req","query","hostname","host","matcher","matches","Object","groupKey","pathToRegexp","validate","parsedDestination","hadLocale","destination","pathname","hash","protocol","port","search","href","destQuery","destPath","destPathParamKeys","destPathParams","destinationCompiler","Array","strOrArray","compileNonPath","paramKeys","name","appendParamsToQuery","newUrl","err"],"mappings":"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","sourcesContent":["import { IncomingMessage } from 'http'\nimport { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\nimport { RouteHas } from '../../../../lib/load-custom-routes'\n\ntype Params = { [param: string]: any }\n\n// ensure only a-zA-Z are used for param names for proper interpolating\n// with path-to-regexp\nexport const getSafeParamName = (paramName: string) => {\n  let newParamName = ''\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i)\n\n    if (\n      (charCode > 64 && charCode < 91) || // A-Z\n      (charCode > 96 && charCode < 123) // a-z\n    ) {\n      newParamName += paramName[i]\n    }\n  }\n  return newParamName\n}\n\nexport function matchHas(\n  req: IncomingMessage,\n  has: RouteHas[],\n  query: Params\n): false | Params {\n  const params: Params = {}\n  const allMatch = has.every((hasItem) => {\n    let value: undefined | string\n    let key = hasItem.key\n\n    switch (hasItem.type) {\n      case 'header': {\n        key = key!.toLowerCase()\n        value = req.headers[key] as string\n        break\n      }\n      case 'cookie': {\n        value = (req as any).cookies[hasItem.key]\n        break\n      }\n      case 'query': {\n        value = query[key!]\n        break\n      }\n      case 'host': {\n        const { host } = req?.headers || {}\n        // remove port from host if present\n        const hostname = host?.split(':')[0].toLowerCase()\n        value = hostname\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key!)] = value\n      return true\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`)\n      const matches = value.match(matcher)\n\n      if (matches) {\n        if (matches.groups) {\n          Object.keys(matches.groups).forEach((groupKey) => {\n            params[groupKey] = matches.groups![groupKey]\n          })\n        } else if (hasItem.type === 'host' && matches[0]) {\n          params.host = matches[0]\n        }\n        return true\n      }\n    }\n    return false\n  })\n\n  if (allMatch) {\n    return params\n  }\n  return false\n}\n\nexport function compileNonPath(value: string, params: Params): string {\n  if (!value.includes(':')) {\n    return value\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value\n        .replace(\n          new RegExp(`:${key}\\\\*`, 'g'),\n          `:${key}--ESCAPED_PARAM_ASTERISKS`\n        )\n        .replace(\n          new RegExp(`:${key}\\\\?`, 'g'),\n          `:${key}--ESCAPED_PARAM_QUESTION`\n        )\n        .replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)\n        .replace(\n          new RegExp(`:${key}(?!\\\\w)`, 'g'),\n          `--ESCAPED_PARAM_COLON${key}`\n        )\n    }\n  }\n  value = value\n    .replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1')\n    .replace(/--ESCAPED_PARAM_PLUS/g, '+')\n    .replace(/--ESCAPED_PARAM_COLON/g, ':')\n    .replace(/--ESCAPED_PARAM_QUESTION/g, '?')\n    .replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')\n\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return pathToRegexp\n    .compile(`/${value}`, { validate: false })(params)\n    .substr(1)\n}\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  const hadLocale = query.__nextLocale\n  delete query.__nextLocale\n  delete query.__nextDefaultLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = compileNonPath(value, params)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(params)\n\n  // remove internal param for i18n\n  if (hadLocale) {\n    paramKeys = paramKeys.filter((name) => name !== 'nextInternalLocale')\n  }\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  try {\n    newUrl = destinationCompiler(params)\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete (parsedDestination as any).search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}