{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports.closePing=closePing;exports.setupPing=setupPing;exports.currentPage=void 0;var _eventsource=require(\"./error-overlay/eventsource\");var evtSource;var currentPage;exports.currentPage=currentPage;function closePing(){if(evtSource)evtSource.close();evtSource=null;}function setupPing(assetPrefix,pathnameFn,retry){var pathname=pathnameFn();if(pathname===currentPage&&!retry)return;exports.currentPage=currentPage=pathname;closePing();evtSource=(0,_eventsource.getEventSourceWrapper)({path:assetPrefix+\"/_next/webpack-hmr?page=\"+currentPage,timeout:5000});evtSource.addMessageListener(function(event){if(event.data.indexOf('{')===-1)return;try{var payload=JSON.parse(event.data);if(payload.invalid){fetch(location.href,{credentials:'same-origin'}).then(function(pageRes){if(pageRes.status===200){location.reload();}});}}catch(err){console.error('on-demand-entries failed to parse response',err);}});}","map":{"version":3,"sources":["../../../client/dev/on-demand-entries-utils.js"],"names":["evtSource","pathname","pathnameFn","closePing","path","assetPrefix","timeout","event","payload","JSON","fetch","location","credentials","pageRes","console"],"mappings":"wHACA,GAAA,CAAA,YAAA,CAAA,OADA,+BACA,CAEA,GAAA,CAAA,SAAA,CACO,GAAA,CAAA,WAAA,C,gCAEA,QAAA,CAAA,SAAA,EAAqB,CAC1B,GAAA,SAAA,CAAeA,SAAS,CAATA,KAAAA,GACfA,SAAS,CAATA,IAAAA,CAGK,SAAA,CAAA,SAAA,CAAA,WAAA,CAAA,UAAA,CAAA,KAAA,CAAmD,CACxD,GAAMC,CAAAA,QAAQ,CAAGC,UAAjB,EAAA,CAGA,GAAID,QAAQ,GAARA,WAAAA,EAA4B,CAAhC,KAAA,CAAwC,OACxC,OAAA,CAAA,WAAA,CAAA,WAAW,CAAX,QAAA,CAEAE,SAAS,GAETH,SAAS,CAAG,CAAA,EAAA,YAAA,CAAA,qBAAA,EAAsB,CAChCI,IAAI,CAAKC,WAAL,4BAD4B,WAAA,CAEhCC,OAAO,CAFTN,IAAkC,CAAtB,CAAZA,CAKAA,SAAS,CAATA,kBAAAA,CAA8BO,SAAAA,KAAD,CAAW,CACtC,GAAIA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAAA,GAAAA,IAA4B,CAAhC,CAAA,CAAoC,OACpC,GAAI,CACF,GAAMC,CAAAA,OAAO,CAAGC,IAAI,CAAJA,KAAAA,CAAWF,KAAK,CAAhC,IAAgBE,CAAhB,CACA,GAAID,OAAO,CAAX,OAAA,CAAqB,CAGnBE,KAAK,CAACC,QAAQ,CAAT,IAAA,CAAgB,CACnBC,WAAW,CADbF,aAAqB,CAAhB,CAALA,CAAAA,IAAAA,CAESG,SAAAA,OAAD,CAAa,CACnB,GAAIA,OAAO,CAAPA,MAAAA,GAAJ,GAAA,CAA4B,CAC1BF,QAAQ,CAARA,MAAAA,GAEH,CANDD,CAAAA,EAQH,CAAC,OAAA,GAAA,CAAY,CACZI,OAAO,CAAPA,KAAAA,CAAAA,4CAAAA,CAAAA,GAAAA,EAEH,CAlBDd,CAAAA,EAmBD","sourcesContent":["/* global location */\nimport { getEventSourceWrapper } from './error-overlay/eventsource'\n\nlet evtSource\nexport let currentPage\n\nexport function closePing() {\n  if (evtSource) evtSource.close()\n  evtSource = null\n}\n\nexport function setupPing(assetPrefix, pathnameFn, retry) {\n  const pathname = pathnameFn()\n\n  // Make sure to only create new EventSource request if page has changed\n  if (pathname === currentPage && !retry) return\n  currentPage = pathname\n  // close current EventSource connection\n  closePing()\n\n  evtSource = getEventSourceWrapper({\n    path: `${assetPrefix}/_next/webpack-hmr?page=${currentPage}`,\n    timeout: 5000,\n  })\n\n  evtSource.addMessageListener((event) => {\n    if (event.data.indexOf('{') === -1) return\n    try {\n      const payload = JSON.parse(event.data)\n      if (payload.invalid) {\n        // Payload can be invalid even if the page does not exist.\n        // So, we need to make sure it exists before reloading.\n        fetch(location.href, {\n          credentials: 'same-origin',\n        }).then((pageRes) => {\n          if (pageRes.status === 200) {\n            location.reload()\n          }\n        })\n      }\n    } catch (err) {\n      console.error('on-demand-entries failed to parse response', err)\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}