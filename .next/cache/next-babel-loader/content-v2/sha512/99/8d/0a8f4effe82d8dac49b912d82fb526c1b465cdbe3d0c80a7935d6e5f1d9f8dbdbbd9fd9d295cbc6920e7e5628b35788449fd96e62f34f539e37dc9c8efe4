{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";var arr=['1',2,4,5,6];var a=2;export var TreeNode=function TreeNode(id,name,value,_children){var _this=this;_classCallCheck(this,TreeNode);this.addChildren=function(children){if(!_this.children){_this.children=[];}if(children instanceof Array){_this.children=_this.children.concat(children);}else{_this.children.push(children);}};this.getHeight=function(){var beginRoot=_this;var maxDepth=1;if(beginRoot){var bfs=function bfs(node,level){if(level>maxDepth){maxDepth=level;}var children=node.children;if(children){for(var i=0,len=children.length;i<len;i++){bfs(children[i],level+1);}}};bfs(beginRoot,1);}return maxDepth;};this.id=id;this.name=name||'';this.value=value||undefined;this.children=_children||[];};_c=TreeNode;var _c;$RefreshReg$(_c,\"TreeNode\");","map":{"version":3,"sources":["/Users/revone/projects/expo-react-bunny/src/types/utils.ts"],"names":["arr","a","TreeNode","name","value","children","beginRoot","maxDepth","bfs","level","node","i","len"],"mappings":"mEA4EA,GAAMA,CAAAA,GAAG,CAAG,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAZ,CAAY,CAAZ,CAEA,GAAMC,CAAAA,CAAQ,CAAd,CAAA,CA6CA,MAAA,IAAaC,CAAAA,QAAb,CAMI,QAAA,CAAA,QAAA,CAAA,EAAA,CAAA,IAAA,CAAA,KAAA,CAAA,SAAA,CAA4E,CAAA,GAAA,CAAA,KAAA,CAAA,IAAA,CAAA,eAAA,CAAA,IAAA,CAAA,QAAA,CAAA,CAAA,KAAA,WAAA,CAgB9D,SAAA,QAAA,CAA4C,CACtD,GAAI,CAAC,KAAI,CAAT,QAAA,CAAoB,CAChB,KAAI,CAAJ,QAAA,CAAA,EAAA,CACH,CACD,GAAIG,QAAQ,WAAZ,CAAA,KAAA,CAA+B,CAC3B,KAAI,CAAJ,QAAA,CAAgB,KAAI,CAAJ,QAAA,CAAA,MAAA,CAAhB,QAAgB,CAAhB,CADJ,CAAA,IAEO,CACH,KAAI,CAAJ,QAAA,CAAA,IAAA,CAAA,QAAA,EACH,CAxBuE,CAAA,CAAA,KAAA,SAAA,CA2BhE,UAAM,CACd,GAAMC,CAAAA,SAAS,CAAf,KAAA,CACA,GAAIC,CAAAA,QAAQ,CAAZ,CAAA,CACA,GAAA,SAAA,CAAe,CACX,GAAMC,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,CAAA,IAAA,CAAA,KAAA,CAAsC,CAC9C,GAAIC,KAAK,CAAT,QAAA,CAAsB,CAClBF,QAAQ,CAARA,KAAAA,CACH,CACD,GAAOF,CAAAA,QAAP,CAAmBK,IAAnB,CAAA,QAAA,CACA,GAAA,QAAA,CAAc,CACV,IAAK,GAAIC,CAAAA,CAAC,CAAL,CAAA,CAAWC,GAAG,CAAGP,QAAQ,CAA9B,MAAA,CAAuCM,CAAC,CAAxC,GAAA,CAAgDA,CAAhD,EAAA,CAAqD,CACjDH,GAAG,CAACH,QAAQ,CAAT,CAAS,CAAT,CAAcI,KAAK,CAAtBD,CAAG,CAAHA,CACH,CACJ,CATL,CAAA,CAWAA,GAAG,CAAA,SAAA,CAAHA,CAAG,CAAHA,CACH,CACD,MAAA,CAAA,QAAA,CA5CwE,CAAA,CACxE,KAAA,EAAA,CAAA,EAAA,CACA,KAAA,IAAA,CAAYL,IAAI,EAAhB,EAAA,CACA,KAAA,KAAA,CAAaC,KAAK,EAAlB,SAAA,CACA,KAAA,QAAA,CAAgBC,SAAQ,EAAxB,EAAA,CAVR,CAAA,C,GAAaH,Q","sourcesContent":["// export type DeepLeavesWrap<T, U> = T extends { [key: string]: any } ? { [P in keyof T]: DeepLeavesWrap<T[P], U> }\n//     : T extends { [key: string]: any } | undefined ? { [P in keyof T]: DeepLeavesWrap<T[P], U> }\n//         : T extends boolean ? { [M in keyof U]: boolean }\n//             : T extends string ? { [M in keyof U]: string }\n//                 // Todo : T extends (infer F) ? { [M in keyof U]: F}\n//                 : { [M in keyof U]: T };\ntype AnyFunction = (...args: any[]) => any;\ntype Primitive =\n    | number\n    | string\n    | boolean\n    | symbol\n    | undefined\n    | null\n    | void\n    | AnyFunction\n    | Date;\n\nexport type Cast<T, TComplex> = { [M in keyof TComplex]: T };\n// export type DeepLeavesWrap<T, TComplex> = {\n//     [K in keyof T]: T[K] extends object ? DeepLeavesWrap<T[K], TComplex>\n//         : { [M in keyof TComplex]: T[K] }\n// };\n\nexport type DeepLeavesWrap<T, TComplex> =\n    T extends string ? Cast<string, TComplex>\n        : T extends number ? Cast<number, TComplex>\n            : T extends boolean ? Cast<boolean, TComplex>\n                : T extends undefined ? Cast<undefined, TComplex>\n                    : T extends null ? Cast<null, TComplex>\n                        : T extends void ? Cast<void, TComplex>\n                            : T extends symbol ? Cast<symbol, TComplex>\n                                : T extends AnyFunction ? Cast<AnyFunction, TComplex>\n                                    : T extends Date ? Cast<Date, TComplex>\n                                        : {\n                                            [K in keyof T]:\n                                            T[K] extends (infer U)[] ? DeepLeavesWrap<U, TComplex>[]\n                                                : DeepLeavesWrap<T[K], TComplex>;\n                                        }\n\n\n// export type JSONSerializable = {\n//     [ket: string]: JSONSerializable | boolean | number | string | Array<JSONSerializable | boolean | number | string>\n// }\n\ntype Json = null | string | number | boolean | Json [] | { [name: string]: Json }\n\nexport type JSONSerializable = {\n    [key: string]: any\n}\n\nexport type JSONValue = string | number | boolean | undefined | JSONObject;\n\nexport interface JSONObject {\n    [key: string]: JSONValue;\n}\n\nexport interface JSONArray extends Array<JSONValue> {\n}\n\nexport type TypeName<T> = T extends string\n    ? 'string'\n    : T extends number\n        ? 'number'\n        : T extends boolean\n            ? 'boolean'\n            : T extends undefined\n                ? 'undefined'\n                : T extends Function\n                    ? 'function'\n                    : 'object';\n\nexport type JsonKeys<T> = keyof {\n    [P in keyof T]: number\n}\n\nconst arr = ['1', 2, 4, 5, 6] as const;\ntype Range = typeof arr[number];\nconst a: Range = 2;\n\n\n/**\n * A function that emits a side effect and does not return anything.\n */\nexport type Procedure = (...args: any[]) => void;\n\nexport type DebounceOptions = {\n    isImmediate?: boolean;\n    maxWait?: number;\n};\n\nexport interface DebouncedFunction<F extends Procedure> {\n    (this: ThisParameterType<F>, ...args: Parameters<F>): void;\n\n    cancel: () => void;\n}\n\nexport type MonthKey =\n    'January' |\n    'February' |\n    'March' |\n    'April' |\n    'May' |\n    'June' |\n    'July' |\n    'August' |\n    'September' |\n    'October' |\n    'November' |\n    'December';\n\nexport type Month = { [key in MonthKey]: string }\n\nexport type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never;\n\n\n// export type TreeNode = {\n//     id: string,\n//     name?: string,\n//     value?: number,\n//     children?: TreeNode[]\n// }\n\nexport class TreeNode<T> {\n    id: string;\n    name?: string | undefined;\n    value?: T | undefined;\n    children?: TreeNode<T>[] | undefined;\n\n    constructor(id: string, name?: string, value?: T, children?: TreeNode<T>[]) {\n        this.id = id;\n        this.name = name || '';\n        this.value = value || undefined;\n        this.children = children || [];\n    }\n\n    // TODO get set\n    // get name (): string | undefined {\n    //     return this.name;\n    // }\n    //\n    // set name (name: string | undefined) {\n    //     this.name = name;\n    // }\n\n    addChildren = (children: TreeNode<T> | TreeNode<T> []) => {\n        if (!this.children) {\n            this.children = [];\n        }\n        if (children instanceof Array) {\n            this.children = this.children.concat(children);\n        } else {\n            this.children.push(children);\n        }\n    };\n\n    getHeight = () => {\n        const beginRoot = this;\n        let maxDepth = 1;\n        if (beginRoot) {\n            const bfs = (node: TreeNode<T>, level: number) => {\n                if (level > maxDepth) {\n                    maxDepth = level;\n                }\n                const {children} = node;\n                if (children) {\n                    for (let i = 0, len = children.length; i < len; i++) {\n                        bfs(children[i], level + 1);\n                    }\n                }\n            };\n            bfs(beginRoot, 1);\n        }\n        return maxDepth;\n    };\n\n}\n\n\nexport type OrderType = 'InOrder' | 'PreOrder' | 'PostOrder'\n\n\nexport interface IStack<T> {\n    push(item: T): void;\n\n    pop(): T | undefined;\n\n    peek(): T | undefined;\n\n    size(): number;\n}\n\n"]},"metadata":{},"sourceType":"module"}